# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pylint: disable=all
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import sys
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Callable,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal

# -- template models.py.jinja --
import os
import warnings
from pydantic import BaseConfig, BaseModel, Field, validator

from . import types, enums, errors, fields
from ._types import BaseModelT, FuncType
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


class Config(BaseConfig):
    use_enum_values: bool = True
    arbitrary_types_allowed: bool = True
    allow_population_by_field_name: bool = True
    json_encoders: Dict[Union[Type[Any], str], FuncType] = {
        fields.Base64: serialize_base64,
    }


_created_partial_types: Set[str] = set()


def _warn_subclassing(new_model: str, base_model: str) -> None:
    message = (
        'Subclassing models while using pseudo-recursive types may cause unexpected '
        'errors when static type checking;\n'
        'You can disable this warning by generating fully recursive types: \n'
        'https://prisma-client-py.readthedocs.io/en/stable/reference/config/#recursive\n'
        'or if that is not possible you can pass warn_subclass=False e.g.\n'
        f'  class {new_model}(prisma.models.{base_model}, warn_subclass=False):'
    )
    warnings.warn(message, errors.UnsupportedSubclassWarning, stacklevel=4)


class characters(BaseModel):
    CharacterID: int
    Name: str
    Alias: Optional[str]
    Sex: Optional[str]
    Residences: Optional[str]
    Occupations: Optional[str]
    Url: str

    Config = Config

    @classmethod
    def prisma(cls) -> 'actions.charactersActions':
        from .client import get_client

        return actions.charactersActions(get_client(), cls)

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass:
            _warn_subclassing(cls.__name__, 'characters')

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.charactersKeys']] = None,
        exclude: Optional[Iterable['types.charactersKeys']] = None,
        required: Optional[Iterable['types.charactersKeys']] = None,
        optional: Optional[Iterable['types.charactersKeys']] = None,
        relations: Optional[Mapping['types.charactersRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None and exclude is not None:
            raise TypeError(f'Exclude and include are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.charactersKeys', PartialModelField] = {}

        try:
            if include:
                for field in include:
                    fields[field] = _characters_fields[field]
            elif exclude:
                for field in exclude:
                    if field not in _characters_fields:
                        raise KeyError(field)

                fields = {
                    key: data
                    for key, data in _characters_fields.items()
                    if key not in exclude
                }
            else:
                fields = _characters_fields.copy()

            if required:
                for field in required:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "characters" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid characters / {name} field.'
            ) from None

        models = partial_models_ctx.get()

        # mypy does not like this as we are assigning a
        # Dict[Literal[str]] to a Dict[str] but this is fine
        models[name] = fields  # type: ignore[assignment]
        partial_models_ctx.set(models)
        _created_partial_types.add(name)


class comics_issues(BaseModel):
    ComicsIssueID: int
    IssueNo: Optional[int]
    ComicsStoryID: int
    PublishDate: datetime.datetime
    Annotation: Optional[str]
    comics_stories: Optional['models.comics_stories']

    Config = Config

    @classmethod
    def prisma(cls) -> 'actions.comics_issuesActions':
        from .client import get_client

        return actions.comics_issuesActions(get_client(), cls)

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass:
            _warn_subclassing(cls.__name__, 'comics_issues')

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.comics_issuesKeys']] = None,
        exclude: Optional[Iterable['types.comics_issuesKeys']] = None,
        required: Optional[Iterable['types.comics_issuesKeys']] = None,
        optional: Optional[Iterable['types.comics_issuesKeys']] = None,
        relations: Optional[Mapping['types.comics_issuesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None and exclude is not None:
            raise TypeError(f'Exclude and include are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.comics_issuesKeys', PartialModelField] = {}

        try:
            if include:
                for field in include:
                    fields[field] = _comics_issues_fields[field]
            elif exclude:
                for field in exclude:
                    if field not in _comics_issues_fields:
                        raise KeyError(field)

                fields = {
                    key: data
                    for key, data in _comics_issues_fields.items()
                    if key not in exclude
                }
            else:
                fields = _comics_issues_fields.copy()

            if required:
                for field in required:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in _comics_issues_fields.items()
                    if key not in _comics_issues_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _comics_issues_relational_fields:
                        raise errors.UnknownRelationalFieldError('comics_issues', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid comics_issues / {name} field.'
            ) from None

        models = partial_models_ctx.get()

        # mypy does not like this as we are assigning a
        # Dict[Literal[str]] to a Dict[str] but this is fine
        models[name] = fields  # type: ignore[assignment]
        partial_models_ctx.set(models)
        _created_partial_types.add(name)


class comics_series(BaseModel):
    ComicsSeriesID: int
    Name: str
    Url: str
    comics_stories: Optional[List['models.comics_stories']]

    Config = Config

    @classmethod
    def prisma(cls) -> 'actions.comics_seriesActions':
        from .client import get_client

        return actions.comics_seriesActions(get_client(), cls)

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass:
            _warn_subclassing(cls.__name__, 'comics_series')

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.comics_seriesKeys']] = None,
        exclude: Optional[Iterable['types.comics_seriesKeys']] = None,
        required: Optional[Iterable['types.comics_seriesKeys']] = None,
        optional: Optional[Iterable['types.comics_seriesKeys']] = None,
        relations: Optional[Mapping['types.comics_seriesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None and exclude is not None:
            raise TypeError(f'Exclude and include are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.comics_seriesKeys', PartialModelField] = {}

        try:
            if include:
                for field in include:
                    fields[field] = _comics_series_fields[field]
            elif exclude:
                for field in exclude:
                    if field not in _comics_series_fields:
                        raise KeyError(field)

                fields = {
                    key: data
                    for key, data in _comics_series_fields.items()
                    if key not in exclude
                }
            else:
                fields = _comics_series_fields.copy()

            if required:
                for field in required:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in _comics_series_fields.items()
                    if key not in _comics_series_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _comics_series_relational_fields:
                        raise errors.UnknownRelationalFieldError('comics_series', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid comics_series / {name} field.'
            ) from None

        models = partial_models_ctx.get()

        # mypy does not like this as we are assigning a
        # Dict[Literal[str]] to a Dict[str] but this is fine
        models[name] = fields  # type: ignore[assignment]
        partial_models_ctx.set(models)
        _created_partial_types.add(name)


class comics_stories(BaseModel):
    ComicsStoryID: int
    Name: str
    ComicsSeriesID: int
    ImageID: Optional[int]
    Url: Optional[str]
    Writer: Optional[str]
    Artist: Optional[str]
    Colorist: Optional[str]
    Letterer: Optional[str]
    Editor: Optional[str]
    comics_series: Optional['models.comics_series']
    images: Optional['models.images']
    comics_issues: Optional[List['models.comics_issues']]

    Config = Config

    @classmethod
    def prisma(cls) -> 'actions.comics_storiesActions':
        from .client import get_client

        return actions.comics_storiesActions(get_client(), cls)

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass:
            _warn_subclassing(cls.__name__, 'comics_stories')

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.comics_storiesKeys']] = None,
        exclude: Optional[Iterable['types.comics_storiesKeys']] = None,
        required: Optional[Iterable['types.comics_storiesKeys']] = None,
        optional: Optional[Iterable['types.comics_storiesKeys']] = None,
        relations: Optional[Mapping['types.comics_storiesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None and exclude is not None:
            raise TypeError(f'Exclude and include are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.comics_storiesKeys', PartialModelField] = {}

        try:
            if include:
                for field in include:
                    fields[field] = _comics_stories_fields[field]
            elif exclude:
                for field in exclude:
                    if field not in _comics_stories_fields:
                        raise KeyError(field)

                fields = {
                    key: data
                    for key, data in _comics_stories_fields.items()
                    if key not in exclude
                }
            else:
                fields = _comics_stories_fields.copy()

            if required:
                for field in required:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in _comics_stories_fields.items()
                    if key not in _comics_stories_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _comics_stories_relational_fields:
                        raise errors.UnknownRelationalFieldError('comics_stories', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid comics_stories / {name} field.'
            ) from None

        models = partial_models_ctx.get()

        # mypy does not like this as we are assigning a
        # Dict[Literal[str]] to a Dict[str] but this is fine
        models[name] = fields  # type: ignore[assignment]
        partial_models_ctx.set(models)
        _created_partial_types.add(name)


class episodes(BaseModel):
    EpisodeID: int
    Name: str
    ImageID: int
    Season: Optional[int]
    Episode: Optional[int]
    OverallEpisode: Optional[int]
    Airdate: datetime.datetime
    StoryBy: Optional[str]
    WrittenBy: Optional[str]
    Storyboard: Optional[str]
    Url: str
    images: Optional['models.images']
    songs: Optional[List['models.songs']]

    Config = Config

    @classmethod
    def prisma(cls) -> 'actions.episodesActions':
        from .client import get_client

        return actions.episodesActions(get_client(), cls)

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass:
            _warn_subclassing(cls.__name__, 'episodes')

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.episodesKeys']] = None,
        exclude: Optional[Iterable['types.episodesKeys']] = None,
        required: Optional[Iterable['types.episodesKeys']] = None,
        optional: Optional[Iterable['types.episodesKeys']] = None,
        relations: Optional[Mapping['types.episodesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None and exclude is not None:
            raise TypeError(f'Exclude and include are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.episodesKeys', PartialModelField] = {}

        try:
            if include:
                for field in include:
                    fields[field] = _episodes_fields[field]
            elif exclude:
                for field in exclude:
                    if field not in _episodes_fields:
                        raise KeyError(field)

                fields = {
                    key: data
                    for key, data in _episodes_fields.items()
                    if key not in exclude
                }
            else:
                fields = _episodes_fields.copy()

            if required:
                for field in required:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in _episodes_fields.items()
                    if key not in _episodes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _episodes_relational_fields:
                        raise errors.UnknownRelationalFieldError('episodes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid episodes / {name} field.'
            ) from None

        models = partial_models_ctx.get()

        # mypy does not like this as we are assigning a
        # Dict[Literal[str]] to a Dict[str] but this is fine
        models[name] = fields  # type: ignore[assignment]
        partial_models_ctx.set(models)
        _created_partial_types.add(name)


class images(BaseModel):
    ImageID: int
    Name: str
    Url: str
    Comment: Optional[str]
    comics_stories: Optional[List['models.comics_stories']]
    episodes: Optional[List['models.episodes']]

    Config = Config

    @classmethod
    def prisma(cls) -> 'actions.imagesActions':
        from .client import get_client

        return actions.imagesActions(get_client(), cls)

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass:
            _warn_subclassing(cls.__name__, 'images')

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.imagesKeys']] = None,
        exclude: Optional[Iterable['types.imagesKeys']] = None,
        required: Optional[Iterable['types.imagesKeys']] = None,
        optional: Optional[Iterable['types.imagesKeys']] = None,
        relations: Optional[Mapping['types.imagesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None and exclude is not None:
            raise TypeError(f'Exclude and include are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.imagesKeys', PartialModelField] = {}

        try:
            if include:
                for field in include:
                    fields[field] = _images_fields[field]
            elif exclude:
                for field in exclude:
                    if field not in _images_fields:
                        raise KeyError(field)

                fields = {
                    key: data
                    for key, data in _images_fields.items()
                    if key not in exclude
                }
            else:
                fields = _images_fields.copy()

            if required:
                for field in required:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in _images_fields.items()
                    if key not in _images_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _images_relational_fields:
                        raise errors.UnknownRelationalFieldError('images', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid images / {name} field.'
            ) from None

        models = partial_models_ctx.get()

        # mypy does not like this as we are assigning a
        # Dict[Literal[str]] to a Dict[str] but this is fine
        models[name] = fields  # type: ignore[assignment]
        partial_models_ctx.set(models)
        _created_partial_types.add(name)


class kinds(BaseModel):
    KindID: int
    Name: str
    Url: Optional[str]

    Config = Config

    @classmethod
    def prisma(cls) -> 'actions.kindsActions':
        from .client import get_client

        return actions.kindsActions(get_client(), cls)

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass:
            _warn_subclassing(cls.__name__, 'kinds')

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.kindsKeys']] = None,
        exclude: Optional[Iterable['types.kindsKeys']] = None,
        required: Optional[Iterable['types.kindsKeys']] = None,
        optional: Optional[Iterable['types.kindsKeys']] = None,
        relations: Optional[Mapping['types.kindsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None and exclude is not None:
            raise TypeError(f'Exclude and include are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.kindsKeys', PartialModelField] = {}

        try:
            if include:
                for field in include:
                    fields[field] = _kinds_fields[field]
            elif exclude:
                for field in exclude:
                    if field not in _kinds_fields:
                        raise KeyError(field)

                fields = {
                    key: data
                    for key, data in _kinds_fields.items()
                    if key not in exclude
                }
            else:
                fields = _kinds_fields.copy()

            if required:
                for field in required:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "kinds" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid kinds / {name} field.'
            ) from None

        models = partial_models_ctx.get()

        # mypy does not like this as we are assigning a
        # Dict[Literal[str]] to a Dict[str] but this is fine
        models[name] = fields  # type: ignore[assignment]
        partial_models_ctx.set(models)
        _created_partial_types.add(name)


class songs(BaseModel):
    SongID: int
    Name: str
    EpisodeID: int
    VideoUrl: str
    Length: str
    MusicBy: Optional[str]
    LyricsBy: Optional[str]
    KeySignatures: Optional[str]
    Url: str
    episodes: Optional['models.episodes']

    Config = Config

    @classmethod
    def prisma(cls) -> 'actions.songsActions':
        from .client import get_client

        return actions.songsActions(get_client(), cls)

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: bool = True,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass:
            _warn_subclassing(cls.__name__, 'songs')

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.songsKeys']] = None,
        exclude: Optional[Iterable['types.songsKeys']] = None,
        required: Optional[Iterable['types.songsKeys']] = None,
        optional: Optional[Iterable['types.songsKeys']] = None,
        relations: Optional[Mapping['types.songsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None and exclude is not None:
            raise TypeError(f'Exclude and include are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.songsKeys', PartialModelField] = {}

        try:
            if include:
                for field in include:
                    fields[field] = _songs_fields[field]
            elif exclude:
                for field in exclude:
                    if field not in _songs_fields:
                        raise KeyError(field)

                fields = {
                    key: data
                    for key, data in _songs_fields.items()
                    if key not in exclude
                }
            else:
                fields = _songs_fields.copy()

            if required:
                for field in required:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field] = fields[field].copy()
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in _songs_fields.items()
                    if key not in _songs_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _songs_relational_fields:
                        raise errors.UnknownRelationalFieldError('songs', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid songs / {name} field.'
            ) from None

        models = partial_models_ctx.get()

        # mypy does not like this as we are assigning a
        # Dict[Literal[str]] to a Dict[str] but this is fine
        models[name] = fields  # type: ignore[assignment]
        partial_models_ctx.set(models)
        _created_partial_types.add(name)



_characters_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
_characters_fields: Dict['types.charactersKeys', PartialModelField] = {
    'CharacterID': {
        'name': 'CharacterID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'Name': {
        'name': 'Name',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'Alias': {
        'name': 'Alias',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Sex': {
        'name': 'Sex',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Residences': {
        'name': 'Residences',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Occupations': {
        'name': 'Occupations',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Url': {
        'name': 'Url',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
}

_comics_issues_relational_fields: Set[str] = {
        'comics_stories',
    }
_comics_issues_fields: Dict['types.comics_issuesKeys', PartialModelField] = {
    'ComicsIssueID': {
        'name': 'ComicsIssueID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'IssueNo': {
        'name': 'IssueNo',
        'is_list': False,
        'optional': True,
        'type': 'int',
    },
    'ComicsStoryID': {
        'name': 'ComicsStoryID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'PublishDate': {
        'name': 'PublishDate',
        'is_list': False,
        'optional': False,
        'type': 'datetime.datetime',
    },
    'Annotation': {
        'name': 'Annotation',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'comics_stories': {
        'name': 'comics_stories',
        'is_list': False,
        'optional': True,
        'type': 'models.comics_stories',
    },
}

_comics_series_relational_fields: Set[str] = {
        'comics_stories',
    }
_comics_series_fields: Dict['types.comics_seriesKeys', PartialModelField] = {
    'ComicsSeriesID': {
        'name': 'ComicsSeriesID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'Name': {
        'name': 'Name',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'Url': {
        'name': 'Url',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'comics_stories': {
        'name': 'comics_stories',
        'is_list': True,
        'optional': True,
        'type': 'List[\'models.comics_stories\']',
    },
}

_comics_stories_relational_fields: Set[str] = {
        'comics_series',
        'images',
        'comics_issues',
    }
_comics_stories_fields: Dict['types.comics_storiesKeys', PartialModelField] = {
    'ComicsStoryID': {
        'name': 'ComicsStoryID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'Name': {
        'name': 'Name',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'ComicsSeriesID': {
        'name': 'ComicsSeriesID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'ImageID': {
        'name': 'ImageID',
        'is_list': False,
        'optional': True,
        'type': 'int',
    },
    'Url': {
        'name': 'Url',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Writer': {
        'name': 'Writer',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Artist': {
        'name': 'Artist',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Colorist': {
        'name': 'Colorist',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Letterer': {
        'name': 'Letterer',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Editor': {
        'name': 'Editor',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'comics_series': {
        'name': 'comics_series',
        'is_list': False,
        'optional': True,
        'type': 'models.comics_series',
    },
    'images': {
        'name': 'images',
        'is_list': False,
        'optional': True,
        'type': 'models.images',
    },
    'comics_issues': {
        'name': 'comics_issues',
        'is_list': True,
        'optional': True,
        'type': 'List[\'models.comics_issues\']',
    },
}

_episodes_relational_fields: Set[str] = {
        'images',
        'songs',
    }
_episodes_fields: Dict['types.episodesKeys', PartialModelField] = {
    'EpisodeID': {
        'name': 'EpisodeID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'Name': {
        'name': 'Name',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'ImageID': {
        'name': 'ImageID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'Season': {
        'name': 'Season',
        'is_list': False,
        'optional': True,
        'type': 'int',
    },
    'Episode': {
        'name': 'Episode',
        'is_list': False,
        'optional': True,
        'type': 'int',
    },
    'OverallEpisode': {
        'name': 'OverallEpisode',
        'is_list': False,
        'optional': True,
        'type': 'int',
    },
    'Airdate': {
        'name': 'Airdate',
        'is_list': False,
        'optional': False,
        'type': 'datetime.datetime',
    },
    'StoryBy': {
        'name': 'StoryBy',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'WrittenBy': {
        'name': 'WrittenBy',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Storyboard': {
        'name': 'Storyboard',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Url': {
        'name': 'Url',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'images': {
        'name': 'images',
        'is_list': False,
        'optional': True,
        'type': 'models.images',
    },
    'songs': {
        'name': 'songs',
        'is_list': True,
        'optional': True,
        'type': 'List[\'models.songs\']',
    },
}

_images_relational_fields: Set[str] = {
        'comics_stories',
        'episodes',
    }
_images_fields: Dict['types.imagesKeys', PartialModelField] = {
    'ImageID': {
        'name': 'ImageID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'Name': {
        'name': 'Name',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'Url': {
        'name': 'Url',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'Comment': {
        'name': 'Comment',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'comics_stories': {
        'name': 'comics_stories',
        'is_list': True,
        'optional': True,
        'type': 'List[\'models.comics_stories\']',
    },
    'episodes': {
        'name': 'episodes',
        'is_list': True,
        'optional': True,
        'type': 'List[\'models.episodes\']',
    },
}

_kinds_relational_fields: Set[str] = set()  # pyright: reportUnusedVariable=false
_kinds_fields: Dict['types.kindsKeys', PartialModelField] = {
    'KindID': {
        'name': 'KindID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'Name': {
        'name': 'Name',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'Url': {
        'name': 'Url',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
}

_songs_relational_fields: Set[str] = {
        'episodes',
    }
_songs_fields: Dict['types.songsKeys', PartialModelField] = {
    'SongID': {
        'name': 'SongID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'Name': {
        'name': 'Name',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'EpisodeID': {
        'name': 'EpisodeID',
        'is_list': False,
        'optional': False,
        'type': 'int',
    },
    'VideoUrl': {
        'name': 'VideoUrl',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'Length': {
        'name': 'Length',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'MusicBy': {
        'name': 'MusicBy',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'LyricsBy': {
        'name': 'LyricsBy',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'KeySignatures': {
        'name': 'KeySignatures',
        'is_list': False,
        'optional': True,
        'type': 'str',
    },
    'Url': {
        'name': 'Url',
        'is_list': False,
        'optional': False,
        'type': 'str',
    },
    'episodes': {
        'name': 'episodes',
        'is_list': False,
        'optional': True,
        'type': 'models.episodes',
    },
}



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
characters.update_forward_refs()
comics_issues.update_forward_refs()
comics_series.update_forward_refs()
comics_stories.update_forward_refs()
episodes.update_forward_refs()
images.update_forward_refs()
kinds.update_forward_refs()
songs.update_forward_refs()
