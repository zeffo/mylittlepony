# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pylint: disable=all
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import sys
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Callable,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal

# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
            },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
            },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
            },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
            },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[str]]


class _StringListFilterHasInput(TypedDict):
    has: str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[str]


class _StringListUpdatePush(TypedDict):
    push: List[str]


StringListUpdate = Union[
    List[str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[bool]


BooleanListUpdate = Union[
    List[bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[int]]


class _IntListFilterHasInput(TypedDict):
    has: int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[int]


class _IntListUpdatePush(TypedDict):
    push: List[int]


IntListUpdate = Union[
    List[int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[int]]


class _BigIntListFilterHasInput(TypedDict):
    has: int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[int]


class _BigIntListUpdatePush(TypedDict):
    push: List[int]


BigIntListUpdate = Union[
    List[int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[float]]


class _FloatListFilterHasInput(TypedDict):
    has: float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[float]


class _FloatListUpdatePush(TypedDict):
    push: List[float]


FloatListUpdate = Union[
    List[float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]


# characters types

class charactersOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the characters create method"""
    CharacterID: int
    Alias: Optional[str]
    Sex: Optional[str]
    Residences: Optional[str]
    Occupations: Optional[str]


class charactersCreateInput(charactersOptionalCreateInput):
    """Required arguments to the characters create method"""
    Name: str
    Url: str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class charactersOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the characters create method, without relations"""
    CharacterID: int
    Alias: Optional[str]
    Sex: Optional[str]
    Residences: Optional[str]
    Occupations: Optional[str]


class charactersCreateWithoutRelationsInput(charactersOptionalCreateWithoutRelationsInput):
    """Required arguments to the characters create method, without relations"""
    Name: str
    Url: str


class charactersCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'charactersCreateWithoutRelationsInput'
    connect: 'charactersWhereUniqueInput'


class charactersCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['charactersCreateWithoutRelationsInput', List['charactersCreateWithoutRelationsInput']]
    connect: Union['charactersWhereUniqueInput', List['charactersWhereUniqueInput']]


_charactersWhereUnique_CharacterID_Input = TypedDict(
    '_charactersWhereUnique_CharacterID_Input',
    {
        'CharacterID': 'int',
    },
    total=True
)

_charactersWhereUnique_Name_Input = TypedDict(
    '_charactersWhereUnique_Name_Input',
    {
        'Name': 'str',
    },
    total=True
)

charactersWhereUniqueInput = Union[
    '_charactersWhereUnique_CharacterID_Input',
    '_charactersWhereUnique_Name_Input',
]


class charactersUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    CharacterID: Union[AtomicIntInput, int]
    Name: str
    Alias: Optional[str]
    Sex: Optional[str]
    Residences: Optional[str]
    Occupations: Optional[str]
    Url: str


class charactersUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    CharacterID: Union[AtomicIntInput, int]
    Name: str
    Alias: Optional[str]
    Sex: Optional[str]
    Residences: Optional[str]
    Occupations: Optional[str]
    Url: str


class charactersUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['charactersCreateWithoutRelationsInput']
    connect: List['charactersWhereUniqueInput']
    set: List['charactersWhereUniqueInput']
    disconnect: List['charactersWhereUniqueInput']
    delete: List['charactersWhereUniqueInput']

    # TODO
    # update: List['charactersUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['charactersUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['charactersScalarWhereInput']
    # upsert: List['charactersUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['charactersCreateOrConnectWithoutRelationsInput']


class charactersUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'charactersCreateWithoutRelationsInput'
    connect: 'charactersWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'charactersUpdateInput'
    # upsert: 'charactersUpsertWithoutRelationsInput'
    # connectOrCreate: 'charactersCreateOrConnectWithoutRelationsInput'


class charactersUpsertInput(TypedDict):
    create: 'charactersCreateInput'
    update: 'charactersUpdateInput'  # pyright: reportIncompatibleMethodOverride=false


_characters_CharacterID_OrderByInput = TypedDict(
    '_characters_CharacterID_OrderByInput',
    {
        'CharacterID': 'SortOrder',
    },
    total=True
)

_characters_Name_OrderByInput = TypedDict(
    '_characters_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_characters_Alias_OrderByInput = TypedDict(
    '_characters_Alias_OrderByInput',
    {
        'Alias': 'SortOrder',
    },
    total=True
)

_characters_Sex_OrderByInput = TypedDict(
    '_characters_Sex_OrderByInput',
    {
        'Sex': 'SortOrder',
    },
    total=True
)

_characters_Residences_OrderByInput = TypedDict(
    '_characters_Residences_OrderByInput',
    {
        'Residences': 'SortOrder',
    },
    total=True
)

_characters_Occupations_OrderByInput = TypedDict(
    '_characters_Occupations_OrderByInput',
    {
        'Occupations': 'SortOrder',
    },
    total=True
)

_characters_Url_OrderByInput = TypedDict(
    '_characters_Url_OrderByInput',
    {
        'Url': 'SortOrder',
    },
    total=True
)

charactersOrderByInput = Union[
    '_characters_CharacterID_OrderByInput',
    '_characters_Name_OrderByInput',
    '_characters_Alias_OrderByInput',
    '_characters_Sex_OrderByInput',
    '_characters_Residences_OrderByInput',
    '_characters_Occupations_OrderByInput',
    '_characters_Url_OrderByInput',
]



# recursive characters types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

charactersRelationFilter = TypedDict(
    'charactersRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class charactersListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class charactersInclude(TypedDict, total=False):
    """characters relational arguments"""


    

class charactersIncludeFromcharacters(TypedDict, total=False):
    """Relational arguments for characters"""


class charactersIncludeFromcharactersRecursive1(TypedDict, total=False):
    """Relational arguments for characters"""


class charactersIncludeFromcharactersRecursive2(TypedDict, total=False):
    """Relational arguments for characters"""


class charactersIncludeFromcharactersRecursive3(TypedDict, total=False):
    """Relational arguments for characters"""


class charactersIncludeFromcharactersRecursive4(TypedDict, total=False):
    """Relational arguments for characters"""

    

class charactersArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    include: 'charactersIncludeFromcharactersRecursive1'


class charactersArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    include: 'charactersIncludeFromcharactersRecursive2'


class charactersArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    include: 'charactersIncludeFromcharactersRecursive3'


class charactersArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    include: 'charactersIncludeFromcharactersRecursive4'


class charactersArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    
    

class FindManycharactersArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive1'


class FindManycharactersArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive2'


class FindManycharactersArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive3'


class FindManycharactersArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive4'


class FindManycharactersArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    
    

class comics_issuesIncludeFromcharacters(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcharactersRecursive1']


class comics_issuesIncludeFromcharactersRecursive1(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcharactersRecursive2']


class comics_issuesIncludeFromcharactersRecursive2(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcharactersRecursive3']


class comics_issuesIncludeFromcharactersRecursive3(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcharactersRecursive4']


class comics_issuesIncludeFromcharactersRecursive4(TypedDict, total=False):
    """Relational arguments for characters"""

    

class comics_issuesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class comics_issuesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class comics_issuesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class comics_issuesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class comics_issuesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    
    

class FindManycomics_issuesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class FindManycomics_issuesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class FindManycomics_issuesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class FindManycomics_issuesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class FindManycomics_issuesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    
    

class comics_seriesIncludeFromcharacters(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcharactersRecursive1']


class comics_seriesIncludeFromcharactersRecursive1(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcharactersRecursive2']


class comics_seriesIncludeFromcharactersRecursive2(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcharactersRecursive3']


class comics_seriesIncludeFromcharactersRecursive3(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcharactersRecursive4']


class comics_seriesIncludeFromcharactersRecursive4(TypedDict, total=False):
    """Relational arguments for characters"""

    

class comics_seriesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class comics_seriesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class comics_seriesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class comics_seriesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class comics_seriesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    
    

class FindManycomics_seriesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class FindManycomics_seriesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class FindManycomics_seriesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class FindManycomics_seriesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class FindManycomics_seriesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    
    

class comics_storiesIncludeFromcharacters(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_series: Union[bool, 'comics_seriesArgsFromcharactersRecursive1']
    images: Union[bool, 'imagesArgsFromcharactersRecursive1']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcharactersRecursive1']


class comics_storiesIncludeFromcharactersRecursive1(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_series: Union[bool, 'comics_seriesArgsFromcharactersRecursive2']
    images: Union[bool, 'imagesArgsFromcharactersRecursive2']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcharactersRecursive2']


class comics_storiesIncludeFromcharactersRecursive2(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_series: Union[bool, 'comics_seriesArgsFromcharactersRecursive3']
    images: Union[bool, 'imagesArgsFromcharactersRecursive3']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcharactersRecursive3']


class comics_storiesIncludeFromcharactersRecursive3(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_series: Union[bool, 'comics_seriesArgsFromcharactersRecursive4']
    images: Union[bool, 'imagesArgsFromcharactersRecursive4']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcharactersRecursive4']


class comics_storiesIncludeFromcharactersRecursive4(TypedDict, total=False):
    """Relational arguments for characters"""

    

class comics_storiesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class comics_storiesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class comics_storiesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class comics_storiesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class comics_storiesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    
    

class FindManycomics_storiesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class FindManycomics_storiesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class FindManycomics_storiesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class FindManycomics_storiesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class FindManycomics_storiesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    
    

class episodesIncludeFromcharacters(TypedDict, total=False):
    """Relational arguments for characters"""
    images: Union[bool, 'imagesArgsFromcharactersRecursive1']
    songs: Union[bool, 'FindManysongsArgsFromcharactersRecursive1']


class episodesIncludeFromcharactersRecursive1(TypedDict, total=False):
    """Relational arguments for characters"""
    images: Union[bool, 'imagesArgsFromcharactersRecursive2']
    songs: Union[bool, 'FindManysongsArgsFromcharactersRecursive2']


class episodesIncludeFromcharactersRecursive2(TypedDict, total=False):
    """Relational arguments for characters"""
    images: Union[bool, 'imagesArgsFromcharactersRecursive3']
    songs: Union[bool, 'FindManysongsArgsFromcharactersRecursive3']


class episodesIncludeFromcharactersRecursive3(TypedDict, total=False):
    """Relational arguments for characters"""
    images: Union[bool, 'imagesArgsFromcharactersRecursive4']
    songs: Union[bool, 'FindManysongsArgsFromcharactersRecursive4']


class episodesIncludeFromcharactersRecursive4(TypedDict, total=False):
    """Relational arguments for characters"""

    

class episodesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    include: 'episodesIncludeFromepisodesRecursive1'


class episodesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    include: 'episodesIncludeFromepisodesRecursive2'


class episodesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    include: 'episodesIncludeFromepisodesRecursive3'


class episodesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    include: 'episodesIncludeFromepisodesRecursive4'


class episodesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    
    

class FindManyepisodesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive1'


class FindManyepisodesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive2'


class FindManyepisodesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive3'


class FindManyepisodesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive4'


class FindManyepisodesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    
    

class imagesIncludeFromcharacters(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcharactersRecursive1']
    episodes: Union[bool, 'FindManyepisodesArgsFromcharactersRecursive1']


class imagesIncludeFromcharactersRecursive1(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcharactersRecursive2']
    episodes: Union[bool, 'FindManyepisodesArgsFromcharactersRecursive2']


class imagesIncludeFromcharactersRecursive2(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcharactersRecursive3']
    episodes: Union[bool, 'FindManyepisodesArgsFromcharactersRecursive3']


class imagesIncludeFromcharactersRecursive3(TypedDict, total=False):
    """Relational arguments for characters"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcharactersRecursive4']
    episodes: Union[bool, 'FindManyepisodesArgsFromcharactersRecursive4']


class imagesIncludeFromcharactersRecursive4(TypedDict, total=False):
    """Relational arguments for characters"""

    

class imagesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    include: 'imagesIncludeFromimagesRecursive1'


class imagesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    include: 'imagesIncludeFromimagesRecursive2'


class imagesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    include: 'imagesIncludeFromimagesRecursive3'


class imagesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    include: 'imagesIncludeFromimagesRecursive4'


class imagesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    
    

class FindManyimagesArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive1'


class FindManyimagesArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive2'


class FindManyimagesArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive3'


class FindManyimagesArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive4'


class FindManyimagesArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    
    

class kindsIncludeFromcharacters(TypedDict, total=False):
    """Relational arguments for characters"""


class kindsIncludeFromcharactersRecursive1(TypedDict, total=False):
    """Relational arguments for characters"""


class kindsIncludeFromcharactersRecursive2(TypedDict, total=False):
    """Relational arguments for characters"""


class kindsIncludeFromcharactersRecursive3(TypedDict, total=False):
    """Relational arguments for characters"""


class kindsIncludeFromcharactersRecursive4(TypedDict, total=False):
    """Relational arguments for characters"""

    

class kindsArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    include: 'kindsIncludeFromkindsRecursive1'


class kindsArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    include: 'kindsIncludeFromkindsRecursive2'


class kindsArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    include: 'kindsIncludeFromkindsRecursive3'


class kindsArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    include: 'kindsIncludeFromkindsRecursive4'


class kindsArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    
    

class FindManykindsArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive1'


class FindManykindsArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive2'


class FindManykindsArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive3'


class FindManykindsArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive4'


class FindManykindsArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    
    

class songsIncludeFromcharacters(TypedDict, total=False):
    """Relational arguments for characters"""
    episodes: Union[bool, 'episodesArgsFromcharactersRecursive1']


class songsIncludeFromcharactersRecursive1(TypedDict, total=False):
    """Relational arguments for characters"""
    episodes: Union[bool, 'episodesArgsFromcharactersRecursive2']


class songsIncludeFromcharactersRecursive2(TypedDict, total=False):
    """Relational arguments for characters"""
    episodes: Union[bool, 'episodesArgsFromcharactersRecursive3']


class songsIncludeFromcharactersRecursive3(TypedDict, total=False):
    """Relational arguments for characters"""
    episodes: Union[bool, 'episodesArgsFromcharactersRecursive4']


class songsIncludeFromcharactersRecursive4(TypedDict, total=False):
    """Relational arguments for characters"""

    

class songsArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    include: 'songsIncludeFromsongsRecursive1'


class songsArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    include: 'songsIncludeFromsongsRecursive2'


class songsArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    include: 'songsIncludeFromsongsRecursive3'


class songsArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    include: 'songsIncludeFromsongsRecursive4'


class songsArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    
    

class FindManysongsArgsFromcharacters(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive1'


class FindManysongsArgsFromcharactersRecursive1(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive2'


class FindManysongsArgsFromcharactersRecursive2(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive3'


class FindManysongsArgsFromcharactersRecursive3(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive4'


class FindManysongsArgsFromcharactersRecursive4(TypedDict, total=False):
    """Arguments for characters"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    


FindManycharactersArgs = FindManycharactersArgsFromcharacters
FindFirstcharactersArgs = FindManycharactersArgsFromcharacters


    

class charactersWhereInput(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Alias: Union[str, 'types.StringFilter']
    Sex: Union[str, 'types.StringFilter']
    Residences: Union[str, 'types.StringFilter']
    Occupations: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['charactersWhereInputRecursive1', List['charactersWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['charactersWhereInputRecursive1']
    OR: List['charactersWhereInputRecursive1']
    NOT: List['charactersWhereInputRecursive1']


class charactersWhereInputRecursive1(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Alias: Union[str, 'types.StringFilter']
    Sex: Union[str, 'types.StringFilter']
    Residences: Union[str, 'types.StringFilter']
    Occupations: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['charactersWhereInputRecursive2', List['charactersWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['charactersWhereInputRecursive2']
    OR: List['charactersWhereInputRecursive2']
    NOT: List['charactersWhereInputRecursive2']


class charactersWhereInputRecursive2(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Alias: Union[str, 'types.StringFilter']
    Sex: Union[str, 'types.StringFilter']
    Residences: Union[str, 'types.StringFilter']
    Occupations: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['charactersWhereInputRecursive3', List['charactersWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['charactersWhereInputRecursive3']
    OR: List['charactersWhereInputRecursive3']
    NOT: List['charactersWhereInputRecursive3']


class charactersWhereInputRecursive3(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Alias: Union[str, 'types.StringFilter']
    Sex: Union[str, 'types.StringFilter']
    Residences: Union[str, 'types.StringFilter']
    Occupations: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['charactersWhereInputRecursive4', List['charactersWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['charactersWhereInputRecursive4']
    OR: List['charactersWhereInputRecursive4']
    NOT: List['charactersWhereInputRecursive4']


class charactersWhereInputRecursive4(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Alias: Union[str, 'types.StringFilter']
    Sex: Union[str, 'types.StringFilter']
    Residences: Union[str, 'types.StringFilter']
    Occupations: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']



# aggregate characters types


    

class charactersScalarWhereWithAggregatesInput(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Alias: Union[str, 'types.StringWithAggregatesFilter']
    Sex: Union[str, 'types.StringWithAggregatesFilter']
    Residences: Union[str, 'types.StringWithAggregatesFilter']
    Occupations: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['charactersScalarWhereWithAggregatesInputRecursive1']
    OR: List['charactersScalarWhereWithAggregatesInputRecursive1']
    NOT: List['charactersScalarWhereWithAggregatesInputRecursive1']


class charactersScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Alias: Union[str, 'types.StringWithAggregatesFilter']
    Sex: Union[str, 'types.StringWithAggregatesFilter']
    Residences: Union[str, 'types.StringWithAggregatesFilter']
    Occupations: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['charactersScalarWhereWithAggregatesInputRecursive2']
    OR: List['charactersScalarWhereWithAggregatesInputRecursive2']
    NOT: List['charactersScalarWhereWithAggregatesInputRecursive2']


class charactersScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Alias: Union[str, 'types.StringWithAggregatesFilter']
    Sex: Union[str, 'types.StringWithAggregatesFilter']
    Residences: Union[str, 'types.StringWithAggregatesFilter']
    Occupations: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['charactersScalarWhereWithAggregatesInputRecursive3']
    OR: List['charactersScalarWhereWithAggregatesInputRecursive3']
    NOT: List['charactersScalarWhereWithAggregatesInputRecursive3']


class charactersScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Alias: Union[str, 'types.StringWithAggregatesFilter']
    Sex: Union[str, 'types.StringWithAggregatesFilter']
    Residences: Union[str, 'types.StringWithAggregatesFilter']
    Occupations: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['charactersScalarWhereWithAggregatesInputRecursive4']
    OR: List['charactersScalarWhereWithAggregatesInputRecursive4']
    NOT: List['charactersScalarWhereWithAggregatesInputRecursive4']


class charactersScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """characters arguments for searching"""
    CharacterID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Alias: Union[str, 'types.StringWithAggregatesFilter']
    Sex: Union[str, 'types.StringWithAggregatesFilter']
    Residences: Union[str, 'types.StringWithAggregatesFilter']
    Occupations: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']



class charactersGroupByOutput(TypedDict, total=False):
    CharacterID: int
    Name: str
    Alias: str
    Sex: str
    Residences: str
    Occupations: str
    Url: str
    _sum: 'charactersSumAggregateOutput'
    _avg: 'charactersAvgAggregateOutput'
    _min: 'charactersMinAggregateOutput'
    _max: 'charactersMaxAggregateOutput'
    _count: 'charactersCountAggregateOutput'


class charactersAvgAggregateOutput(TypedDict, total=False):
    """characters output for aggregating averages"""
    CharacterID: float


class charactersSumAggregateOutput(TypedDict, total=False):
    """characters output for aggregating sums"""
    CharacterID: int


class charactersScalarAggregateOutput(TypedDict, total=False):
    """characters output including scalar fields"""
    CharacterID: int
    Name: str
    Alias: str
    Sex: str
    Residences: str
    Occupations: str
    Url: str


charactersMinAggregateOutput = charactersScalarAggregateOutput
charactersMaxAggregateOutput = charactersScalarAggregateOutput


class charactersMaxAggregateInput(TypedDict, total=False):
    """characters input for aggregating by max"""
    CharacterID: bool
    Name: bool
    Alias: bool
    Sex: bool
    Residences: bool
    Occupations: bool
    Url: bool


class charactersMinAggregateInput(TypedDict, total=False):
    """characters input for aggregating by min"""
    CharacterID: bool
    Name: bool
    Alias: bool
    Sex: bool
    Residences: bool
    Occupations: bool
    Url: bool


class charactersNumberAggregateInput(TypedDict, total=False):
    """characters input for aggregating numbers"""
    CharacterID: bool


charactersAvgAggregateInput = charactersNumberAggregateInput
charactersSumAggregateInput = charactersNumberAggregateInput


charactersCountAggregateInput = TypedDict(
    'charactersCountAggregateInput',
    {
        'CharacterID': bool,
        'Name': bool,
        'Alias': bool,
        'Sex': bool,
        'Residences': bool,
        'Occupations': bool,
        'Url': bool,
        '_all': bool,
    },
    total=False,
)

charactersCountAggregateOutput = TypedDict(
    'charactersCountAggregateOutput',
    {
        'CharacterID': int,
        'Name': int,
        'Alias': int,
        'Sex': int,
        'Residences': int,
        'Occupations': int,
        'Url': int,
        '_all': int,
    },
    total=False,
)


charactersKeys = Literal[
    'CharacterID',
    'Name',
    'Alias',
    'Sex',
    'Residences',
    'Occupations',
    'Url',
]
charactersScalarFieldKeys = Literal[
    'CharacterID',
    'Name',
    'Alias',
    'Sex',
    'Residences',
    'Occupations',
    'Url',
]
charactersScalarFieldKeysT = TypeVar('charactersScalarFieldKeysT', bound=charactersScalarFieldKeys)

charactersRelationalFieldKeys = _NoneType

# comics_issues types

class comics_issuesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the comics_issues create method"""
    ComicsIssueID: int
    IssueNo: Optional[int]
    Annotation: Optional[str]
    comics_stories: 'comics_storiesCreateNestedWithoutRelationsInput'


class comics_issuesCreateInput(comics_issuesOptionalCreateInput):
    """Required arguments to the comics_issues create method"""
    PublishDate: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class comics_issuesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the comics_issues create method, without relations"""
    ComicsIssueID: int
    IssueNo: Optional[int]
    Annotation: Optional[str]


class comics_issuesCreateWithoutRelationsInput(comics_issuesOptionalCreateWithoutRelationsInput):
    """Required arguments to the comics_issues create method, without relations"""
    PublishDate: datetime.datetime


class comics_issuesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'comics_issuesCreateWithoutRelationsInput'
    connect: 'comics_issuesWhereUniqueInput'


class comics_issuesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['comics_issuesCreateWithoutRelationsInput', List['comics_issuesCreateWithoutRelationsInput']]
    connect: Union['comics_issuesWhereUniqueInput', List['comics_issuesWhereUniqueInput']]


_comics_issuesWhereUnique_ComicsIssueID_Input = TypedDict(
    '_comics_issuesWhereUnique_ComicsIssueID_Input',
    {
        'ComicsIssueID': 'int',
    },
    total=True
)

comics_issuesWhereUniqueInput = _comics_issuesWhereUnique_ComicsIssueID_Input


class comics_issuesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    ComicsIssueID: Union[AtomicIntInput, int]
    IssueNo: Optional[Union[AtomicIntInput, int]]
    PublishDate: datetime.datetime
    Annotation: Optional[str]
    comics_stories: 'comics_storiesUpdateOneWithoutRelationsInput'


class comics_issuesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    ComicsIssueID: Union[AtomicIntInput, int]
    IssueNo: Optional[Union[AtomicIntInput, int]]
    PublishDate: datetime.datetime
    Annotation: Optional[str]


class comics_issuesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['comics_issuesCreateWithoutRelationsInput']
    connect: List['comics_issuesWhereUniqueInput']
    set: List['comics_issuesWhereUniqueInput']
    disconnect: List['comics_issuesWhereUniqueInput']
    delete: List['comics_issuesWhereUniqueInput']

    # TODO
    # update: List['comics_issuesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['comics_issuesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['comics_issuesScalarWhereInput']
    # upsert: List['comics_issuesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['comics_issuesCreateOrConnectWithoutRelationsInput']


class comics_issuesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'comics_issuesCreateWithoutRelationsInput'
    connect: 'comics_issuesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'comics_issuesUpdateInput'
    # upsert: 'comics_issuesUpsertWithoutRelationsInput'
    # connectOrCreate: 'comics_issuesCreateOrConnectWithoutRelationsInput'


class comics_issuesUpsertInput(TypedDict):
    create: 'comics_issuesCreateInput'
    update: 'comics_issuesUpdateInput'  # pyright: reportIncompatibleMethodOverride=false


_comics_issues_ComicsIssueID_OrderByInput = TypedDict(
    '_comics_issues_ComicsIssueID_OrderByInput',
    {
        'ComicsIssueID': 'SortOrder',
    },
    total=True
)

_comics_issues_IssueNo_OrderByInput = TypedDict(
    '_comics_issues_IssueNo_OrderByInput',
    {
        'IssueNo': 'SortOrder',
    },
    total=True
)

_comics_issues_ComicsStoryID_OrderByInput = TypedDict(
    '_comics_issues_ComicsStoryID_OrderByInput',
    {
        'ComicsStoryID': 'SortOrder',
    },
    total=True
)

_comics_issues_PublishDate_OrderByInput = TypedDict(
    '_comics_issues_PublishDate_OrderByInput',
    {
        'PublishDate': 'SortOrder',
    },
    total=True
)

_comics_issues_Annotation_OrderByInput = TypedDict(
    '_comics_issues_Annotation_OrderByInput',
    {
        'Annotation': 'SortOrder',
    },
    total=True
)

comics_issuesOrderByInput = Union[
    '_comics_issues_ComicsIssueID_OrderByInput',
    '_comics_issues_IssueNo_OrderByInput',
    '_comics_issues_ComicsStoryID_OrderByInput',
    '_comics_issues_PublishDate_OrderByInput',
    '_comics_issues_Annotation_OrderByInput',
]



# recursive comics_issues types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

comics_issuesRelationFilter = TypedDict(
    'comics_issuesRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class comics_issuesListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class comics_issuesInclude(TypedDict, total=False):
    """comics_issues relational arguments"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_issues']


    

class charactersIncludeFromcomics_issues(TypedDict, total=False):
    """Relational arguments for comics_issues"""


class charactersIncludeFromcomics_issuesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_issues"""


class charactersIncludeFromcomics_issuesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_issues"""


class charactersIncludeFromcomics_issuesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_issues"""


class charactersIncludeFromcomics_issuesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_issues"""

    

class charactersArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'charactersIncludeFromcharactersRecursive1'


class charactersArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'charactersIncludeFromcharactersRecursive2'


class charactersArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'charactersIncludeFromcharactersRecursive3'


class charactersArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'charactersIncludeFromcharactersRecursive4'


class charactersArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    
    

class FindManycharactersArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive1'


class FindManycharactersArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive2'


class FindManycharactersArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive3'


class FindManycharactersArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive4'


class FindManycharactersArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    
    

class comics_issuesIncludeFromcomics_issues(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_issuesRecursive1']


class comics_issuesIncludeFromcomics_issuesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_issuesRecursive2']


class comics_issuesIncludeFromcomics_issuesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_issuesRecursive3']


class comics_issuesIncludeFromcomics_issuesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_issuesRecursive4']


class comics_issuesIncludeFromcomics_issuesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_issues"""

    

class comics_issuesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class comics_issuesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class comics_issuesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class comics_issuesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class comics_issuesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    
    

class FindManycomics_issuesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class FindManycomics_issuesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class FindManycomics_issuesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class FindManycomics_issuesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class FindManycomics_issuesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    
    

class comics_seriesIncludeFromcomics_issues(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_issuesRecursive1']


class comics_seriesIncludeFromcomics_issuesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_issuesRecursive2']


class comics_seriesIncludeFromcomics_issuesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_issuesRecursive3']


class comics_seriesIncludeFromcomics_issuesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_issuesRecursive4']


class comics_seriesIncludeFromcomics_issuesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_issues"""

    

class comics_seriesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class comics_seriesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class comics_seriesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class comics_seriesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class comics_seriesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    
    

class FindManycomics_seriesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class FindManycomics_seriesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class FindManycomics_seriesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class FindManycomics_seriesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class FindManycomics_seriesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    
    

class comics_storiesIncludeFromcomics_issues(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_issuesRecursive1']
    images: Union[bool, 'imagesArgsFromcomics_issuesRecursive1']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_issuesRecursive1']


class comics_storiesIncludeFromcomics_issuesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_issuesRecursive2']
    images: Union[bool, 'imagesArgsFromcomics_issuesRecursive2']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_issuesRecursive2']


class comics_storiesIncludeFromcomics_issuesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_issuesRecursive3']
    images: Union[bool, 'imagesArgsFromcomics_issuesRecursive3']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_issuesRecursive3']


class comics_storiesIncludeFromcomics_issuesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_issuesRecursive4']
    images: Union[bool, 'imagesArgsFromcomics_issuesRecursive4']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_issuesRecursive4']


class comics_storiesIncludeFromcomics_issuesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_issues"""

    

class comics_storiesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class comics_storiesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class comics_storiesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class comics_storiesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class comics_storiesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    
    

class FindManycomics_storiesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class FindManycomics_storiesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class FindManycomics_storiesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class FindManycomics_storiesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class FindManycomics_storiesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    
    

class episodesIncludeFromcomics_issues(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    images: Union[bool, 'imagesArgsFromcomics_issuesRecursive1']
    songs: Union[bool, 'FindManysongsArgsFromcomics_issuesRecursive1']


class episodesIncludeFromcomics_issuesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    images: Union[bool, 'imagesArgsFromcomics_issuesRecursive2']
    songs: Union[bool, 'FindManysongsArgsFromcomics_issuesRecursive2']


class episodesIncludeFromcomics_issuesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    images: Union[bool, 'imagesArgsFromcomics_issuesRecursive3']
    songs: Union[bool, 'FindManysongsArgsFromcomics_issuesRecursive3']


class episodesIncludeFromcomics_issuesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    images: Union[bool, 'imagesArgsFromcomics_issuesRecursive4']
    songs: Union[bool, 'FindManysongsArgsFromcomics_issuesRecursive4']


class episodesIncludeFromcomics_issuesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_issues"""

    

class episodesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'episodesIncludeFromepisodesRecursive1'


class episodesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'episodesIncludeFromepisodesRecursive2'


class episodesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'episodesIncludeFromepisodesRecursive3'


class episodesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'episodesIncludeFromepisodesRecursive4'


class episodesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    
    

class FindManyepisodesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive1'


class FindManyepisodesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive2'


class FindManyepisodesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive3'


class FindManyepisodesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive4'


class FindManyepisodesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    
    

class imagesIncludeFromcomics_issues(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_issuesRecursive1']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_issuesRecursive1']


class imagesIncludeFromcomics_issuesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_issuesRecursive2']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_issuesRecursive2']


class imagesIncludeFromcomics_issuesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_issuesRecursive3']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_issuesRecursive3']


class imagesIncludeFromcomics_issuesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_issuesRecursive4']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_issuesRecursive4']


class imagesIncludeFromcomics_issuesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_issues"""

    

class imagesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'imagesIncludeFromimagesRecursive1'


class imagesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'imagesIncludeFromimagesRecursive2'


class imagesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'imagesIncludeFromimagesRecursive3'


class imagesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'imagesIncludeFromimagesRecursive4'


class imagesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    
    

class FindManyimagesArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive1'


class FindManyimagesArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive2'


class FindManyimagesArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive3'


class FindManyimagesArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive4'


class FindManyimagesArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    
    

class kindsIncludeFromcomics_issues(TypedDict, total=False):
    """Relational arguments for comics_issues"""


class kindsIncludeFromcomics_issuesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_issues"""


class kindsIncludeFromcomics_issuesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_issues"""


class kindsIncludeFromcomics_issuesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_issues"""


class kindsIncludeFromcomics_issuesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_issues"""

    

class kindsArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'kindsIncludeFromkindsRecursive1'


class kindsArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'kindsIncludeFromkindsRecursive2'


class kindsArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'kindsIncludeFromkindsRecursive3'


class kindsArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'kindsIncludeFromkindsRecursive4'


class kindsArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    
    

class FindManykindsArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive1'


class FindManykindsArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive2'


class FindManykindsArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive3'


class FindManykindsArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive4'


class FindManykindsArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    
    

class songsIncludeFromcomics_issues(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    episodes: Union[bool, 'episodesArgsFromcomics_issuesRecursive1']


class songsIncludeFromcomics_issuesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    episodes: Union[bool, 'episodesArgsFromcomics_issuesRecursive2']


class songsIncludeFromcomics_issuesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    episodes: Union[bool, 'episodesArgsFromcomics_issuesRecursive3']


class songsIncludeFromcomics_issuesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_issues"""
    episodes: Union[bool, 'episodesArgsFromcomics_issuesRecursive4']


class songsIncludeFromcomics_issuesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_issues"""

    

class songsArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'songsIncludeFromsongsRecursive1'


class songsArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'songsIncludeFromsongsRecursive2'


class songsArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'songsIncludeFromsongsRecursive3'


class songsArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    include: 'songsIncludeFromsongsRecursive4'


class songsArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    
    

class FindManysongsArgsFromcomics_issues(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive1'


class FindManysongsArgsFromcomics_issuesRecursive1(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive2'


class FindManysongsArgsFromcomics_issuesRecursive2(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive3'


class FindManysongsArgsFromcomics_issuesRecursive3(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive4'


class FindManysongsArgsFromcomics_issuesRecursive4(TypedDict, total=False):
    """Arguments for comics_issues"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    


FindManycomics_issuesArgs = FindManycomics_issuesArgsFromcomics_issues
FindFirstcomics_issuesArgs = FindManycomics_issuesArgsFromcomics_issues


    

class comics_issuesWhereInput(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntFilter']
    IssueNo: Union[int, 'types.IntFilter']
    ComicsStoryID: Union[int, 'types.IntFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeFilter']
    Annotation: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesRelationFilter'

    # should be noted that AND and NOT should be Union['comics_issuesWhereInputRecursive1', List['comics_issuesWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['comics_issuesWhereInputRecursive1']
    OR: List['comics_issuesWhereInputRecursive1']
    NOT: List['comics_issuesWhereInputRecursive1']


class comics_issuesWhereInputRecursive1(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntFilter']
    IssueNo: Union[int, 'types.IntFilter']
    ComicsStoryID: Union[int, 'types.IntFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeFilter']
    Annotation: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesRelationFilter'

    # should be noted that AND and NOT should be Union['comics_issuesWhereInputRecursive2', List['comics_issuesWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['comics_issuesWhereInputRecursive2']
    OR: List['comics_issuesWhereInputRecursive2']
    NOT: List['comics_issuesWhereInputRecursive2']


class comics_issuesWhereInputRecursive2(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntFilter']
    IssueNo: Union[int, 'types.IntFilter']
    ComicsStoryID: Union[int, 'types.IntFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeFilter']
    Annotation: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesRelationFilter'

    # should be noted that AND and NOT should be Union['comics_issuesWhereInputRecursive3', List['comics_issuesWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['comics_issuesWhereInputRecursive3']
    OR: List['comics_issuesWhereInputRecursive3']
    NOT: List['comics_issuesWhereInputRecursive3']


class comics_issuesWhereInputRecursive3(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntFilter']
    IssueNo: Union[int, 'types.IntFilter']
    ComicsStoryID: Union[int, 'types.IntFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeFilter']
    Annotation: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesRelationFilter'

    # should be noted that AND and NOT should be Union['comics_issuesWhereInputRecursive4', List['comics_issuesWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['comics_issuesWhereInputRecursive4']
    OR: List['comics_issuesWhereInputRecursive4']
    NOT: List['comics_issuesWhereInputRecursive4']


class comics_issuesWhereInputRecursive4(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntFilter']
    IssueNo: Union[int, 'types.IntFilter']
    ComicsStoryID: Union[int, 'types.IntFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeFilter']
    Annotation: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesRelationFilter'



# aggregate comics_issues types


    

class comics_issuesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntWithAggregatesFilter']
    IssueNo: Union[int, 'types.IntWithAggregatesFilter']
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Annotation: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_issuesScalarWhereWithAggregatesInputRecursive1']
    OR: List['comics_issuesScalarWhereWithAggregatesInputRecursive1']
    NOT: List['comics_issuesScalarWhereWithAggregatesInputRecursive1']


class comics_issuesScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntWithAggregatesFilter']
    IssueNo: Union[int, 'types.IntWithAggregatesFilter']
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Annotation: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_issuesScalarWhereWithAggregatesInputRecursive2']
    OR: List['comics_issuesScalarWhereWithAggregatesInputRecursive2']
    NOT: List['comics_issuesScalarWhereWithAggregatesInputRecursive2']


class comics_issuesScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntWithAggregatesFilter']
    IssueNo: Union[int, 'types.IntWithAggregatesFilter']
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Annotation: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_issuesScalarWhereWithAggregatesInputRecursive3']
    OR: List['comics_issuesScalarWhereWithAggregatesInputRecursive3']
    NOT: List['comics_issuesScalarWhereWithAggregatesInputRecursive3']


class comics_issuesScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntWithAggregatesFilter']
    IssueNo: Union[int, 'types.IntWithAggregatesFilter']
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Annotation: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_issuesScalarWhereWithAggregatesInputRecursive4']
    OR: List['comics_issuesScalarWhereWithAggregatesInputRecursive4']
    NOT: List['comics_issuesScalarWhereWithAggregatesInputRecursive4']


class comics_issuesScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """comics_issues arguments for searching"""
    ComicsIssueID: Union[int, 'types.IntWithAggregatesFilter']
    IssueNo: Union[int, 'types.IntWithAggregatesFilter']
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    PublishDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Annotation: Union[str, 'types.StringWithAggregatesFilter']



class comics_issuesGroupByOutput(TypedDict, total=False):
    ComicsIssueID: int
    IssueNo: int
    ComicsStoryID: int
    PublishDate: datetime.datetime
    Annotation: str
    _sum: 'comics_issuesSumAggregateOutput'
    _avg: 'comics_issuesAvgAggregateOutput'
    _min: 'comics_issuesMinAggregateOutput'
    _max: 'comics_issuesMaxAggregateOutput'
    _count: 'comics_issuesCountAggregateOutput'


class comics_issuesAvgAggregateOutput(TypedDict, total=False):
    """comics_issues output for aggregating averages"""
    ComicsIssueID: float
    IssueNo: float
    ComicsStoryID: float


class comics_issuesSumAggregateOutput(TypedDict, total=False):
    """comics_issues output for aggregating sums"""
    ComicsIssueID: int
    IssueNo: int
    ComicsStoryID: int


class comics_issuesScalarAggregateOutput(TypedDict, total=False):
    """comics_issues output including scalar fields"""
    ComicsIssueID: int
    IssueNo: int
    ComicsStoryID: int
    PublishDate: datetime.datetime
    Annotation: str


comics_issuesMinAggregateOutput = comics_issuesScalarAggregateOutput
comics_issuesMaxAggregateOutput = comics_issuesScalarAggregateOutput


class comics_issuesMaxAggregateInput(TypedDict, total=False):
    """comics_issues input for aggregating by max"""
    ComicsIssueID: bool
    IssueNo: bool
    ComicsStoryID: bool
    PublishDate: bool
    Annotation: bool


class comics_issuesMinAggregateInput(TypedDict, total=False):
    """comics_issues input for aggregating by min"""
    ComicsIssueID: bool
    IssueNo: bool
    ComicsStoryID: bool
    PublishDate: bool
    Annotation: bool


class comics_issuesNumberAggregateInput(TypedDict, total=False):
    """comics_issues input for aggregating numbers"""
    ComicsIssueID: bool
    IssueNo: bool
    ComicsStoryID: bool


comics_issuesAvgAggregateInput = comics_issuesNumberAggregateInput
comics_issuesSumAggregateInput = comics_issuesNumberAggregateInput


comics_issuesCountAggregateInput = TypedDict(
    'comics_issuesCountAggregateInput',
    {
        'ComicsIssueID': bool,
        'IssueNo': bool,
        'ComicsStoryID': bool,
        'PublishDate': bool,
        'Annotation': bool,
        '_all': bool,
    },
    total=False,
)

comics_issuesCountAggregateOutput = TypedDict(
    'comics_issuesCountAggregateOutput',
    {
        'ComicsIssueID': int,
        'IssueNo': int,
        'ComicsStoryID': int,
        'PublishDate': int,
        'Annotation': int,
        '_all': int,
    },
    total=False,
)


comics_issuesKeys = Literal[
    'ComicsIssueID',
    'IssueNo',
    'ComicsStoryID',
    'PublishDate',
    'Annotation',
    'comics_stories',
]
comics_issuesScalarFieldKeys = Literal[
    'ComicsIssueID',
    'IssueNo',
    'ComicsStoryID',
    'PublishDate',
    'Annotation',
]
comics_issuesScalarFieldKeysT = TypeVar('comics_issuesScalarFieldKeysT', bound=comics_issuesScalarFieldKeys)

comics_issuesRelationalFieldKeys = Literal[
        'comics_stories',
    ]

# comics_series types

class comics_seriesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the comics_series create method"""
    ComicsSeriesID: int
    comics_stories: 'comics_storiesCreateManyNestedWithoutRelationsInput'


class comics_seriesCreateInput(comics_seriesOptionalCreateInput):
    """Required arguments to the comics_series create method"""
    Name: str
    Url: str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class comics_seriesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the comics_series create method, without relations"""
    ComicsSeriesID: int


class comics_seriesCreateWithoutRelationsInput(comics_seriesOptionalCreateWithoutRelationsInput):
    """Required arguments to the comics_series create method, without relations"""
    Name: str
    Url: str


class comics_seriesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'comics_seriesCreateWithoutRelationsInput'
    connect: 'comics_seriesWhereUniqueInput'


class comics_seriesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['comics_seriesCreateWithoutRelationsInput', List['comics_seriesCreateWithoutRelationsInput']]
    connect: Union['comics_seriesWhereUniqueInput', List['comics_seriesWhereUniqueInput']]


_comics_seriesWhereUnique_ComicsSeriesID_Input = TypedDict(
    '_comics_seriesWhereUnique_ComicsSeriesID_Input',
    {
        'ComicsSeriesID': 'int',
    },
    total=True
)

_comics_seriesWhereUnique_Name_Input = TypedDict(
    '_comics_seriesWhereUnique_Name_Input',
    {
        'Name': 'str',
    },
    total=True
)

comics_seriesWhereUniqueInput = Union[
    '_comics_seriesWhereUnique_ComicsSeriesID_Input',
    '_comics_seriesWhereUnique_Name_Input',
]


class comics_seriesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    ComicsSeriesID: Union[AtomicIntInput, int]
    Name: str
    Url: str
    comics_stories: 'comics_storiesUpdateManyWithoutRelationsInput'


class comics_seriesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    ComicsSeriesID: Union[AtomicIntInput, int]
    Name: str
    Url: str


class comics_seriesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['comics_seriesCreateWithoutRelationsInput']
    connect: List['comics_seriesWhereUniqueInput']
    set: List['comics_seriesWhereUniqueInput']
    disconnect: List['comics_seriesWhereUniqueInput']
    delete: List['comics_seriesWhereUniqueInput']

    # TODO
    # update: List['comics_seriesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['comics_seriesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['comics_seriesScalarWhereInput']
    # upsert: List['comics_seriesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['comics_seriesCreateOrConnectWithoutRelationsInput']


class comics_seriesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'comics_seriesCreateWithoutRelationsInput'
    connect: 'comics_seriesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'comics_seriesUpdateInput'
    # upsert: 'comics_seriesUpsertWithoutRelationsInput'
    # connectOrCreate: 'comics_seriesCreateOrConnectWithoutRelationsInput'


class comics_seriesUpsertInput(TypedDict):
    create: 'comics_seriesCreateInput'
    update: 'comics_seriesUpdateInput'  # pyright: reportIncompatibleMethodOverride=false


_comics_series_ComicsSeriesID_OrderByInput = TypedDict(
    '_comics_series_ComicsSeriesID_OrderByInput',
    {
        'ComicsSeriesID': 'SortOrder',
    },
    total=True
)

_comics_series_Name_OrderByInput = TypedDict(
    '_comics_series_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_comics_series_Url_OrderByInput = TypedDict(
    '_comics_series_Url_OrderByInput',
    {
        'Url': 'SortOrder',
    },
    total=True
)

comics_seriesOrderByInput = Union[
    '_comics_series_ComicsSeriesID_OrderByInput',
    '_comics_series_Name_OrderByInput',
    '_comics_series_Url_OrderByInput',
]



# recursive comics_series types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

comics_seriesRelationFilter = TypedDict(
    'comics_seriesRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class comics_seriesListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class comics_seriesInclude(TypedDict, total=False):
    """comics_series relational arguments"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_series']


    

class charactersIncludeFromcomics_series(TypedDict, total=False):
    """Relational arguments for comics_series"""


class charactersIncludeFromcomics_seriesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_series"""


class charactersIncludeFromcomics_seriesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_series"""


class charactersIncludeFromcomics_seriesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_series"""


class charactersIncludeFromcomics_seriesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_series"""

    

class charactersArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'charactersIncludeFromcharactersRecursive1'


class charactersArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'charactersIncludeFromcharactersRecursive2'


class charactersArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'charactersIncludeFromcharactersRecursive3'


class charactersArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'charactersIncludeFromcharactersRecursive4'


class charactersArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    
    

class FindManycharactersArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive1'


class FindManycharactersArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive2'


class FindManycharactersArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive3'


class FindManycharactersArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive4'


class FindManycharactersArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    
    

class comics_issuesIncludeFromcomics_series(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_seriesRecursive1']


class comics_issuesIncludeFromcomics_seriesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_seriesRecursive2']


class comics_issuesIncludeFromcomics_seriesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_seriesRecursive3']


class comics_issuesIncludeFromcomics_seriesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_seriesRecursive4']


class comics_issuesIncludeFromcomics_seriesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_series"""

    

class comics_issuesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class comics_issuesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class comics_issuesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class comics_issuesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class comics_issuesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    
    

class FindManycomics_issuesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class FindManycomics_issuesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class FindManycomics_issuesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class FindManycomics_issuesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class FindManycomics_issuesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    
    

class comics_seriesIncludeFromcomics_series(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_seriesRecursive1']


class comics_seriesIncludeFromcomics_seriesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_seriesRecursive2']


class comics_seriesIncludeFromcomics_seriesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_seriesRecursive3']


class comics_seriesIncludeFromcomics_seriesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_seriesRecursive4']


class comics_seriesIncludeFromcomics_seriesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_series"""

    

class comics_seriesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class comics_seriesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class comics_seriesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class comics_seriesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class comics_seriesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    
    

class FindManycomics_seriesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class FindManycomics_seriesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class FindManycomics_seriesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class FindManycomics_seriesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class FindManycomics_seriesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    
    

class comics_storiesIncludeFromcomics_series(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_seriesRecursive1']
    images: Union[bool, 'imagesArgsFromcomics_seriesRecursive1']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_seriesRecursive1']


class comics_storiesIncludeFromcomics_seriesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_seriesRecursive2']
    images: Union[bool, 'imagesArgsFromcomics_seriesRecursive2']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_seriesRecursive2']


class comics_storiesIncludeFromcomics_seriesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_seriesRecursive3']
    images: Union[bool, 'imagesArgsFromcomics_seriesRecursive3']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_seriesRecursive3']


class comics_storiesIncludeFromcomics_seriesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_seriesRecursive4']
    images: Union[bool, 'imagesArgsFromcomics_seriesRecursive4']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_seriesRecursive4']


class comics_storiesIncludeFromcomics_seriesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_series"""

    

class comics_storiesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class comics_storiesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class comics_storiesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class comics_storiesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class comics_storiesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    
    

class FindManycomics_storiesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class FindManycomics_storiesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class FindManycomics_storiesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class FindManycomics_storiesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class FindManycomics_storiesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    
    

class episodesIncludeFromcomics_series(TypedDict, total=False):
    """Relational arguments for comics_series"""
    images: Union[bool, 'imagesArgsFromcomics_seriesRecursive1']
    songs: Union[bool, 'FindManysongsArgsFromcomics_seriesRecursive1']


class episodesIncludeFromcomics_seriesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_series"""
    images: Union[bool, 'imagesArgsFromcomics_seriesRecursive2']
    songs: Union[bool, 'FindManysongsArgsFromcomics_seriesRecursive2']


class episodesIncludeFromcomics_seriesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_series"""
    images: Union[bool, 'imagesArgsFromcomics_seriesRecursive3']
    songs: Union[bool, 'FindManysongsArgsFromcomics_seriesRecursive3']


class episodesIncludeFromcomics_seriesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_series"""
    images: Union[bool, 'imagesArgsFromcomics_seriesRecursive4']
    songs: Union[bool, 'FindManysongsArgsFromcomics_seriesRecursive4']


class episodesIncludeFromcomics_seriesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_series"""

    

class episodesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'episodesIncludeFromepisodesRecursive1'


class episodesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'episodesIncludeFromepisodesRecursive2'


class episodesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'episodesIncludeFromepisodesRecursive3'


class episodesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'episodesIncludeFromepisodesRecursive4'


class episodesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    
    

class FindManyepisodesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive1'


class FindManyepisodesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive2'


class FindManyepisodesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive3'


class FindManyepisodesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive4'


class FindManyepisodesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    
    

class imagesIncludeFromcomics_series(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_seriesRecursive1']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_seriesRecursive1']


class imagesIncludeFromcomics_seriesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_seriesRecursive2']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_seriesRecursive2']


class imagesIncludeFromcomics_seriesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_seriesRecursive3']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_seriesRecursive3']


class imagesIncludeFromcomics_seriesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_series"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_seriesRecursive4']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_seriesRecursive4']


class imagesIncludeFromcomics_seriesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_series"""

    

class imagesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'imagesIncludeFromimagesRecursive1'


class imagesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'imagesIncludeFromimagesRecursive2'


class imagesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'imagesIncludeFromimagesRecursive3'


class imagesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'imagesIncludeFromimagesRecursive4'


class imagesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    
    

class FindManyimagesArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive1'


class FindManyimagesArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive2'


class FindManyimagesArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive3'


class FindManyimagesArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive4'


class FindManyimagesArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    
    

class kindsIncludeFromcomics_series(TypedDict, total=False):
    """Relational arguments for comics_series"""


class kindsIncludeFromcomics_seriesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_series"""


class kindsIncludeFromcomics_seriesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_series"""


class kindsIncludeFromcomics_seriesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_series"""


class kindsIncludeFromcomics_seriesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_series"""

    

class kindsArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'kindsIncludeFromkindsRecursive1'


class kindsArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'kindsIncludeFromkindsRecursive2'


class kindsArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'kindsIncludeFromkindsRecursive3'


class kindsArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'kindsIncludeFromkindsRecursive4'


class kindsArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    
    

class FindManykindsArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive1'


class FindManykindsArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive2'


class FindManykindsArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive3'


class FindManykindsArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive4'


class FindManykindsArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    
    

class songsIncludeFromcomics_series(TypedDict, total=False):
    """Relational arguments for comics_series"""
    episodes: Union[bool, 'episodesArgsFromcomics_seriesRecursive1']


class songsIncludeFromcomics_seriesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_series"""
    episodes: Union[bool, 'episodesArgsFromcomics_seriesRecursive2']


class songsIncludeFromcomics_seriesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_series"""
    episodes: Union[bool, 'episodesArgsFromcomics_seriesRecursive3']


class songsIncludeFromcomics_seriesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_series"""
    episodes: Union[bool, 'episodesArgsFromcomics_seriesRecursive4']


class songsIncludeFromcomics_seriesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_series"""

    

class songsArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'songsIncludeFromsongsRecursive1'


class songsArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'songsIncludeFromsongsRecursive2'


class songsArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'songsIncludeFromsongsRecursive3'


class songsArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    include: 'songsIncludeFromsongsRecursive4'


class songsArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    
    

class FindManysongsArgsFromcomics_series(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive1'


class FindManysongsArgsFromcomics_seriesRecursive1(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive2'


class FindManysongsArgsFromcomics_seriesRecursive2(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive3'


class FindManysongsArgsFromcomics_seriesRecursive3(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive4'


class FindManysongsArgsFromcomics_seriesRecursive4(TypedDict, total=False):
    """Arguments for comics_series"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    


FindManycomics_seriesArgs = FindManycomics_seriesArgsFromcomics_series
FindFirstcomics_seriesArgs = FindManycomics_seriesArgsFromcomics_series


    

class comics_seriesWhereInput(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'

    # should be noted that AND and NOT should be Union['comics_seriesWhereInputRecursive1', List['comics_seriesWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['comics_seriesWhereInputRecursive1']
    OR: List['comics_seriesWhereInputRecursive1']
    NOT: List['comics_seriesWhereInputRecursive1']


class comics_seriesWhereInputRecursive1(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'

    # should be noted that AND and NOT should be Union['comics_seriesWhereInputRecursive2', List['comics_seriesWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['comics_seriesWhereInputRecursive2']
    OR: List['comics_seriesWhereInputRecursive2']
    NOT: List['comics_seriesWhereInputRecursive2']


class comics_seriesWhereInputRecursive2(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'

    # should be noted that AND and NOT should be Union['comics_seriesWhereInputRecursive3', List['comics_seriesWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['comics_seriesWhereInputRecursive3']
    OR: List['comics_seriesWhereInputRecursive3']
    NOT: List['comics_seriesWhereInputRecursive3']


class comics_seriesWhereInputRecursive3(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'

    # should be noted that AND and NOT should be Union['comics_seriesWhereInputRecursive4', List['comics_seriesWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['comics_seriesWhereInputRecursive4']
    OR: List['comics_seriesWhereInputRecursive4']
    NOT: List['comics_seriesWhereInputRecursive4']


class comics_seriesWhereInputRecursive4(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'



# aggregate comics_series types


    

class comics_seriesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_seriesScalarWhereWithAggregatesInputRecursive1']
    OR: List['comics_seriesScalarWhereWithAggregatesInputRecursive1']
    NOT: List['comics_seriesScalarWhereWithAggregatesInputRecursive1']


class comics_seriesScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_seriesScalarWhereWithAggregatesInputRecursive2']
    OR: List['comics_seriesScalarWhereWithAggregatesInputRecursive2']
    NOT: List['comics_seriesScalarWhereWithAggregatesInputRecursive2']


class comics_seriesScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_seriesScalarWhereWithAggregatesInputRecursive3']
    OR: List['comics_seriesScalarWhereWithAggregatesInputRecursive3']
    NOT: List['comics_seriesScalarWhereWithAggregatesInputRecursive3']


class comics_seriesScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_seriesScalarWhereWithAggregatesInputRecursive4']
    OR: List['comics_seriesScalarWhereWithAggregatesInputRecursive4']
    NOT: List['comics_seriesScalarWhereWithAggregatesInputRecursive4']


class comics_seriesScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """comics_series arguments for searching"""
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']



class comics_seriesGroupByOutput(TypedDict, total=False):
    ComicsSeriesID: int
    Name: str
    Url: str
    _sum: 'comics_seriesSumAggregateOutput'
    _avg: 'comics_seriesAvgAggregateOutput'
    _min: 'comics_seriesMinAggregateOutput'
    _max: 'comics_seriesMaxAggregateOutput'
    _count: 'comics_seriesCountAggregateOutput'


class comics_seriesAvgAggregateOutput(TypedDict, total=False):
    """comics_series output for aggregating averages"""
    ComicsSeriesID: float


class comics_seriesSumAggregateOutput(TypedDict, total=False):
    """comics_series output for aggregating sums"""
    ComicsSeriesID: int


class comics_seriesScalarAggregateOutput(TypedDict, total=False):
    """comics_series output including scalar fields"""
    ComicsSeriesID: int
    Name: str
    Url: str


comics_seriesMinAggregateOutput = comics_seriesScalarAggregateOutput
comics_seriesMaxAggregateOutput = comics_seriesScalarAggregateOutput


class comics_seriesMaxAggregateInput(TypedDict, total=False):
    """comics_series input for aggregating by max"""
    ComicsSeriesID: bool
    Name: bool
    Url: bool


class comics_seriesMinAggregateInput(TypedDict, total=False):
    """comics_series input for aggregating by min"""
    ComicsSeriesID: bool
    Name: bool
    Url: bool


class comics_seriesNumberAggregateInput(TypedDict, total=False):
    """comics_series input for aggregating numbers"""
    ComicsSeriesID: bool


comics_seriesAvgAggregateInput = comics_seriesNumberAggregateInput
comics_seriesSumAggregateInput = comics_seriesNumberAggregateInput


comics_seriesCountAggregateInput = TypedDict(
    'comics_seriesCountAggregateInput',
    {
        'ComicsSeriesID': bool,
        'Name': bool,
        'Url': bool,
        '_all': bool,
    },
    total=False,
)

comics_seriesCountAggregateOutput = TypedDict(
    'comics_seriesCountAggregateOutput',
    {
        'ComicsSeriesID': int,
        'Name': int,
        'Url': int,
        '_all': int,
    },
    total=False,
)


comics_seriesKeys = Literal[
    'ComicsSeriesID',
    'Name',
    'Url',
    'comics_stories',
]
comics_seriesScalarFieldKeys = Literal[
    'ComicsSeriesID',
    'Name',
    'Url',
]
comics_seriesScalarFieldKeysT = TypeVar('comics_seriesScalarFieldKeysT', bound=comics_seriesScalarFieldKeys)

comics_seriesRelationalFieldKeys = Literal[
        'comics_stories',
    ]

# comics_stories types

class comics_storiesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the comics_stories create method"""
    ComicsStoryID: int
    Url: Optional[str]
    Writer: Optional[str]
    Artist: Optional[str]
    Colorist: Optional[str]
    Letterer: Optional[str]
    Editor: Optional[str]
    comics_series: 'comics_seriesCreateNestedWithoutRelationsInput'
    images: 'imagesCreateNestedWithoutRelationsInput'
    comics_issues: 'comics_issuesCreateManyNestedWithoutRelationsInput'


class comics_storiesCreateInput(comics_storiesOptionalCreateInput):
    """Required arguments to the comics_stories create method"""
    Name: str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class comics_storiesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the comics_stories create method, without relations"""
    ComicsStoryID: int
    Url: Optional[str]
    Writer: Optional[str]
    Artist: Optional[str]
    Colorist: Optional[str]
    Letterer: Optional[str]
    Editor: Optional[str]


class comics_storiesCreateWithoutRelationsInput(comics_storiesOptionalCreateWithoutRelationsInput):
    """Required arguments to the comics_stories create method, without relations"""
    Name: str


class comics_storiesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'comics_storiesCreateWithoutRelationsInput'
    connect: 'comics_storiesWhereUniqueInput'


class comics_storiesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['comics_storiesCreateWithoutRelationsInput', List['comics_storiesCreateWithoutRelationsInput']]
    connect: Union['comics_storiesWhereUniqueInput', List['comics_storiesWhereUniqueInput']]


_comics_storiesWhereUnique_ComicsStoryID_Input = TypedDict(
    '_comics_storiesWhereUnique_ComicsStoryID_Input',
    {
        'ComicsStoryID': 'int',
    },
    total=True
)

_comics_storiesWhereUnique_Name_Input = TypedDict(
    '_comics_storiesWhereUnique_Name_Input',
    {
        'Name': 'str',
    },
    total=True
)

_comics_storiesWhereUnique_Url_Input = TypedDict(
    '_comics_storiesWhereUnique_Url_Input',
    {
        'Url': 'str',
    },
    total=True
)

comics_storiesWhereUniqueInput = Union[
    '_comics_storiesWhereUnique_ComicsStoryID_Input',
    '_comics_storiesWhereUnique_Name_Input',
    '_comics_storiesWhereUnique_Url_Input',
]


class comics_storiesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    ComicsStoryID: Union[AtomicIntInput, int]
    Name: str
    Url: Optional[str]
    Writer: Optional[str]
    Artist: Optional[str]
    Colorist: Optional[str]
    Letterer: Optional[str]
    Editor: Optional[str]
    comics_series: 'comics_seriesUpdateOneWithoutRelationsInput'
    images: 'imagesUpdateOneWithoutRelationsInput'
    comics_issues: 'comics_issuesUpdateManyWithoutRelationsInput'


class comics_storiesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    ComicsStoryID: Union[AtomicIntInput, int]
    Name: str
    Url: Optional[str]
    Writer: Optional[str]
    Artist: Optional[str]
    Colorist: Optional[str]
    Letterer: Optional[str]
    Editor: Optional[str]


class comics_storiesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['comics_storiesCreateWithoutRelationsInput']
    connect: List['comics_storiesWhereUniqueInput']
    set: List['comics_storiesWhereUniqueInput']
    disconnect: List['comics_storiesWhereUniqueInput']
    delete: List['comics_storiesWhereUniqueInput']

    # TODO
    # update: List['comics_storiesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['comics_storiesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['comics_storiesScalarWhereInput']
    # upsert: List['comics_storiesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['comics_storiesCreateOrConnectWithoutRelationsInput']


class comics_storiesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'comics_storiesCreateWithoutRelationsInput'
    connect: 'comics_storiesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'comics_storiesUpdateInput'
    # upsert: 'comics_storiesUpsertWithoutRelationsInput'
    # connectOrCreate: 'comics_storiesCreateOrConnectWithoutRelationsInput'


class comics_storiesUpsertInput(TypedDict):
    create: 'comics_storiesCreateInput'
    update: 'comics_storiesUpdateInput'  # pyright: reportIncompatibleMethodOverride=false


_comics_stories_ComicsStoryID_OrderByInput = TypedDict(
    '_comics_stories_ComicsStoryID_OrderByInput',
    {
        'ComicsStoryID': 'SortOrder',
    },
    total=True
)

_comics_stories_Name_OrderByInput = TypedDict(
    '_comics_stories_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_comics_stories_ComicsSeriesID_OrderByInput = TypedDict(
    '_comics_stories_ComicsSeriesID_OrderByInput',
    {
        'ComicsSeriesID': 'SortOrder',
    },
    total=True
)

_comics_stories_ImageID_OrderByInput = TypedDict(
    '_comics_stories_ImageID_OrderByInput',
    {
        'ImageID': 'SortOrder',
    },
    total=True
)

_comics_stories_Url_OrderByInput = TypedDict(
    '_comics_stories_Url_OrderByInput',
    {
        'Url': 'SortOrder',
    },
    total=True
)

_comics_stories_Writer_OrderByInput = TypedDict(
    '_comics_stories_Writer_OrderByInput',
    {
        'Writer': 'SortOrder',
    },
    total=True
)

_comics_stories_Artist_OrderByInput = TypedDict(
    '_comics_stories_Artist_OrderByInput',
    {
        'Artist': 'SortOrder',
    },
    total=True
)

_comics_stories_Colorist_OrderByInput = TypedDict(
    '_comics_stories_Colorist_OrderByInput',
    {
        'Colorist': 'SortOrder',
    },
    total=True
)

_comics_stories_Letterer_OrderByInput = TypedDict(
    '_comics_stories_Letterer_OrderByInput',
    {
        'Letterer': 'SortOrder',
    },
    total=True
)

_comics_stories_Editor_OrderByInput = TypedDict(
    '_comics_stories_Editor_OrderByInput',
    {
        'Editor': 'SortOrder',
    },
    total=True
)

comics_storiesOrderByInput = Union[
    '_comics_stories_ComicsStoryID_OrderByInput',
    '_comics_stories_Name_OrderByInput',
    '_comics_stories_ComicsSeriesID_OrderByInput',
    '_comics_stories_ImageID_OrderByInput',
    '_comics_stories_Url_OrderByInput',
    '_comics_stories_Writer_OrderByInput',
    '_comics_stories_Artist_OrderByInput',
    '_comics_stories_Colorist_OrderByInput',
    '_comics_stories_Letterer_OrderByInput',
    '_comics_stories_Editor_OrderByInput',
]



# recursive comics_stories types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

comics_storiesRelationFilter = TypedDict(
    'comics_storiesRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class comics_storiesListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class comics_storiesInclude(TypedDict, total=False):
    """comics_stories relational arguments"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_stories']
    images: Union[bool, 'imagesArgsFromcomics_stories']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_stories']


    

class charactersIncludeFromcomics_stories(TypedDict, total=False):
    """Relational arguments for comics_stories"""


class charactersIncludeFromcomics_storiesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_stories"""


class charactersIncludeFromcomics_storiesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_stories"""


class charactersIncludeFromcomics_storiesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_stories"""


class charactersIncludeFromcomics_storiesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_stories"""

    

class charactersArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'charactersIncludeFromcharactersRecursive1'


class charactersArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'charactersIncludeFromcharactersRecursive2'


class charactersArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'charactersIncludeFromcharactersRecursive3'


class charactersArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'charactersIncludeFromcharactersRecursive4'


class charactersArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    
    

class FindManycharactersArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive1'


class FindManycharactersArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive2'


class FindManycharactersArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive3'


class FindManycharactersArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive4'


class FindManycharactersArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    
    

class comics_issuesIncludeFromcomics_stories(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_storiesRecursive1']


class comics_issuesIncludeFromcomics_storiesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_storiesRecursive2']


class comics_issuesIncludeFromcomics_storiesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_storiesRecursive3']


class comics_issuesIncludeFromcomics_storiesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'comics_storiesArgsFromcomics_storiesRecursive4']


class comics_issuesIncludeFromcomics_storiesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_stories"""

    

class comics_issuesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class comics_issuesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class comics_issuesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class comics_issuesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class comics_issuesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    
    

class FindManycomics_issuesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class FindManycomics_issuesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class FindManycomics_issuesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class FindManycomics_issuesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class FindManycomics_issuesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    
    

class comics_seriesIncludeFromcomics_stories(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_storiesRecursive1']


class comics_seriesIncludeFromcomics_storiesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_storiesRecursive2']


class comics_seriesIncludeFromcomics_storiesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_storiesRecursive3']


class comics_seriesIncludeFromcomics_storiesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_storiesRecursive4']


class comics_seriesIncludeFromcomics_storiesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_stories"""

    

class comics_seriesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class comics_seriesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class comics_seriesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class comics_seriesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class comics_seriesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    
    

class FindManycomics_seriesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class FindManycomics_seriesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class FindManycomics_seriesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class FindManycomics_seriesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class FindManycomics_seriesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    
    

class comics_storiesIncludeFromcomics_stories(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_storiesRecursive1']
    images: Union[bool, 'imagesArgsFromcomics_storiesRecursive1']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_storiesRecursive1']


class comics_storiesIncludeFromcomics_storiesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_storiesRecursive2']
    images: Union[bool, 'imagesArgsFromcomics_storiesRecursive2']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_storiesRecursive2']


class comics_storiesIncludeFromcomics_storiesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_storiesRecursive3']
    images: Union[bool, 'imagesArgsFromcomics_storiesRecursive3']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_storiesRecursive3']


class comics_storiesIncludeFromcomics_storiesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_series: Union[bool, 'comics_seriesArgsFromcomics_storiesRecursive4']
    images: Union[bool, 'imagesArgsFromcomics_storiesRecursive4']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromcomics_storiesRecursive4']


class comics_storiesIncludeFromcomics_storiesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_stories"""

    

class comics_storiesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class comics_storiesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class comics_storiesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class comics_storiesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class comics_storiesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    
    

class FindManycomics_storiesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class FindManycomics_storiesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class FindManycomics_storiesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class FindManycomics_storiesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class FindManycomics_storiesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    
    

class episodesIncludeFromcomics_stories(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    images: Union[bool, 'imagesArgsFromcomics_storiesRecursive1']
    songs: Union[bool, 'FindManysongsArgsFromcomics_storiesRecursive1']


class episodesIncludeFromcomics_storiesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    images: Union[bool, 'imagesArgsFromcomics_storiesRecursive2']
    songs: Union[bool, 'FindManysongsArgsFromcomics_storiesRecursive2']


class episodesIncludeFromcomics_storiesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    images: Union[bool, 'imagesArgsFromcomics_storiesRecursive3']
    songs: Union[bool, 'FindManysongsArgsFromcomics_storiesRecursive3']


class episodesIncludeFromcomics_storiesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    images: Union[bool, 'imagesArgsFromcomics_storiesRecursive4']
    songs: Union[bool, 'FindManysongsArgsFromcomics_storiesRecursive4']


class episodesIncludeFromcomics_storiesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_stories"""

    

class episodesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'episodesIncludeFromepisodesRecursive1'


class episodesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'episodesIncludeFromepisodesRecursive2'


class episodesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'episodesIncludeFromepisodesRecursive3'


class episodesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'episodesIncludeFromepisodesRecursive4'


class episodesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    
    

class FindManyepisodesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive1'


class FindManyepisodesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive2'


class FindManyepisodesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive3'


class FindManyepisodesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive4'


class FindManyepisodesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    
    

class imagesIncludeFromcomics_stories(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_storiesRecursive1']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_storiesRecursive1']


class imagesIncludeFromcomics_storiesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_storiesRecursive2']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_storiesRecursive2']


class imagesIncludeFromcomics_storiesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_storiesRecursive3']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_storiesRecursive3']


class imagesIncludeFromcomics_storiesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromcomics_storiesRecursive4']
    episodes: Union[bool, 'FindManyepisodesArgsFromcomics_storiesRecursive4']


class imagesIncludeFromcomics_storiesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_stories"""

    

class imagesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'imagesIncludeFromimagesRecursive1'


class imagesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'imagesIncludeFromimagesRecursive2'


class imagesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'imagesIncludeFromimagesRecursive3'


class imagesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'imagesIncludeFromimagesRecursive4'


class imagesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    
    

class FindManyimagesArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive1'


class FindManyimagesArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive2'


class FindManyimagesArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive3'


class FindManyimagesArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive4'


class FindManyimagesArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    
    

class kindsIncludeFromcomics_stories(TypedDict, total=False):
    """Relational arguments for comics_stories"""


class kindsIncludeFromcomics_storiesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_stories"""


class kindsIncludeFromcomics_storiesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_stories"""


class kindsIncludeFromcomics_storiesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_stories"""


class kindsIncludeFromcomics_storiesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_stories"""

    

class kindsArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'kindsIncludeFromkindsRecursive1'


class kindsArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'kindsIncludeFromkindsRecursive2'


class kindsArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'kindsIncludeFromkindsRecursive3'


class kindsArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'kindsIncludeFromkindsRecursive4'


class kindsArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    
    

class FindManykindsArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive1'


class FindManykindsArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive2'


class FindManykindsArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive3'


class FindManykindsArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive4'


class FindManykindsArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    
    

class songsIncludeFromcomics_stories(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    episodes: Union[bool, 'episodesArgsFromcomics_storiesRecursive1']


class songsIncludeFromcomics_storiesRecursive1(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    episodes: Union[bool, 'episodesArgsFromcomics_storiesRecursive2']


class songsIncludeFromcomics_storiesRecursive2(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    episodes: Union[bool, 'episodesArgsFromcomics_storiesRecursive3']


class songsIncludeFromcomics_storiesRecursive3(TypedDict, total=False):
    """Relational arguments for comics_stories"""
    episodes: Union[bool, 'episodesArgsFromcomics_storiesRecursive4']


class songsIncludeFromcomics_storiesRecursive4(TypedDict, total=False):
    """Relational arguments for comics_stories"""

    

class songsArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'songsIncludeFromsongsRecursive1'


class songsArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'songsIncludeFromsongsRecursive2'


class songsArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'songsIncludeFromsongsRecursive3'


class songsArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    include: 'songsIncludeFromsongsRecursive4'


class songsArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    
    

class FindManysongsArgsFromcomics_stories(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive1'


class FindManysongsArgsFromcomics_storiesRecursive1(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive2'


class FindManysongsArgsFromcomics_storiesRecursive2(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive3'


class FindManysongsArgsFromcomics_storiesRecursive3(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive4'


class FindManysongsArgsFromcomics_storiesRecursive4(TypedDict, total=False):
    """Arguments for comics_stories"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    


FindManycomics_storiesArgs = FindManycomics_storiesArgsFromcomics_stories
FindFirstcomics_storiesArgs = FindManycomics_storiesArgsFromcomics_stories


    

class comics_storiesWhereInput(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ComicsSeriesID: Union[int, 'types.IntFilter']
    ImageID: Union[int, 'types.IntFilter']
    Url: Union[str, 'types.StringFilter']
    Writer: Union[str, 'types.StringFilter']
    Artist: Union[str, 'types.StringFilter']
    Colorist: Union[str, 'types.StringFilter']
    Letterer: Union[str, 'types.StringFilter']
    Editor: Union[str, 'types.StringFilter']
    comics_series: 'comics_seriesRelationFilter'
    images: 'imagesRelationFilter'
    comics_issues: 'comics_issuesListRelationFilter'

    # should be noted that AND and NOT should be Union['comics_storiesWhereInputRecursive1', List['comics_storiesWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['comics_storiesWhereInputRecursive1']
    OR: List['comics_storiesWhereInputRecursive1']
    NOT: List['comics_storiesWhereInputRecursive1']


class comics_storiesWhereInputRecursive1(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ComicsSeriesID: Union[int, 'types.IntFilter']
    ImageID: Union[int, 'types.IntFilter']
    Url: Union[str, 'types.StringFilter']
    Writer: Union[str, 'types.StringFilter']
    Artist: Union[str, 'types.StringFilter']
    Colorist: Union[str, 'types.StringFilter']
    Letterer: Union[str, 'types.StringFilter']
    Editor: Union[str, 'types.StringFilter']
    comics_series: 'comics_seriesRelationFilter'
    images: 'imagesRelationFilter'
    comics_issues: 'comics_issuesListRelationFilter'

    # should be noted that AND and NOT should be Union['comics_storiesWhereInputRecursive2', List['comics_storiesWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['comics_storiesWhereInputRecursive2']
    OR: List['comics_storiesWhereInputRecursive2']
    NOT: List['comics_storiesWhereInputRecursive2']


class comics_storiesWhereInputRecursive2(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ComicsSeriesID: Union[int, 'types.IntFilter']
    ImageID: Union[int, 'types.IntFilter']
    Url: Union[str, 'types.StringFilter']
    Writer: Union[str, 'types.StringFilter']
    Artist: Union[str, 'types.StringFilter']
    Colorist: Union[str, 'types.StringFilter']
    Letterer: Union[str, 'types.StringFilter']
    Editor: Union[str, 'types.StringFilter']
    comics_series: 'comics_seriesRelationFilter'
    images: 'imagesRelationFilter'
    comics_issues: 'comics_issuesListRelationFilter'

    # should be noted that AND and NOT should be Union['comics_storiesWhereInputRecursive3', List['comics_storiesWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['comics_storiesWhereInputRecursive3']
    OR: List['comics_storiesWhereInputRecursive3']
    NOT: List['comics_storiesWhereInputRecursive3']


class comics_storiesWhereInputRecursive3(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ComicsSeriesID: Union[int, 'types.IntFilter']
    ImageID: Union[int, 'types.IntFilter']
    Url: Union[str, 'types.StringFilter']
    Writer: Union[str, 'types.StringFilter']
    Artist: Union[str, 'types.StringFilter']
    Colorist: Union[str, 'types.StringFilter']
    Letterer: Union[str, 'types.StringFilter']
    Editor: Union[str, 'types.StringFilter']
    comics_series: 'comics_seriesRelationFilter'
    images: 'imagesRelationFilter'
    comics_issues: 'comics_issuesListRelationFilter'

    # should be noted that AND and NOT should be Union['comics_storiesWhereInputRecursive4', List['comics_storiesWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['comics_storiesWhereInputRecursive4']
    OR: List['comics_storiesWhereInputRecursive4']
    NOT: List['comics_storiesWhereInputRecursive4']


class comics_storiesWhereInputRecursive4(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ComicsSeriesID: Union[int, 'types.IntFilter']
    ImageID: Union[int, 'types.IntFilter']
    Url: Union[str, 'types.StringFilter']
    Writer: Union[str, 'types.StringFilter']
    Artist: Union[str, 'types.StringFilter']
    Colorist: Union[str, 'types.StringFilter']
    Letterer: Union[str, 'types.StringFilter']
    Editor: Union[str, 'types.StringFilter']
    comics_series: 'comics_seriesRelationFilter'
    images: 'imagesRelationFilter'
    comics_issues: 'comics_issuesListRelationFilter'



# aggregate comics_stories types


    

class comics_storiesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Writer: Union[str, 'types.StringWithAggregatesFilter']
    Artist: Union[str, 'types.StringWithAggregatesFilter']
    Colorist: Union[str, 'types.StringWithAggregatesFilter']
    Letterer: Union[str, 'types.StringWithAggregatesFilter']
    Editor: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_storiesScalarWhereWithAggregatesInputRecursive1']
    OR: List['comics_storiesScalarWhereWithAggregatesInputRecursive1']
    NOT: List['comics_storiesScalarWhereWithAggregatesInputRecursive1']


class comics_storiesScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Writer: Union[str, 'types.StringWithAggregatesFilter']
    Artist: Union[str, 'types.StringWithAggregatesFilter']
    Colorist: Union[str, 'types.StringWithAggregatesFilter']
    Letterer: Union[str, 'types.StringWithAggregatesFilter']
    Editor: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_storiesScalarWhereWithAggregatesInputRecursive2']
    OR: List['comics_storiesScalarWhereWithAggregatesInputRecursive2']
    NOT: List['comics_storiesScalarWhereWithAggregatesInputRecursive2']


class comics_storiesScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Writer: Union[str, 'types.StringWithAggregatesFilter']
    Artist: Union[str, 'types.StringWithAggregatesFilter']
    Colorist: Union[str, 'types.StringWithAggregatesFilter']
    Letterer: Union[str, 'types.StringWithAggregatesFilter']
    Editor: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_storiesScalarWhereWithAggregatesInputRecursive3']
    OR: List['comics_storiesScalarWhereWithAggregatesInputRecursive3']
    NOT: List['comics_storiesScalarWhereWithAggregatesInputRecursive3']


class comics_storiesScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Writer: Union[str, 'types.StringWithAggregatesFilter']
    Artist: Union[str, 'types.StringWithAggregatesFilter']
    Colorist: Union[str, 'types.StringWithAggregatesFilter']
    Letterer: Union[str, 'types.StringWithAggregatesFilter']
    Editor: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['comics_storiesScalarWhereWithAggregatesInputRecursive4']
    OR: List['comics_storiesScalarWhereWithAggregatesInputRecursive4']
    NOT: List['comics_storiesScalarWhereWithAggregatesInputRecursive4']


class comics_storiesScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """comics_stories arguments for searching"""
    ComicsStoryID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ComicsSeriesID: Union[int, 'types.IntWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Writer: Union[str, 'types.StringWithAggregatesFilter']
    Artist: Union[str, 'types.StringWithAggregatesFilter']
    Colorist: Union[str, 'types.StringWithAggregatesFilter']
    Letterer: Union[str, 'types.StringWithAggregatesFilter']
    Editor: Union[str, 'types.StringWithAggregatesFilter']



class comics_storiesGroupByOutput(TypedDict, total=False):
    ComicsStoryID: int
    Name: str
    ComicsSeriesID: int
    ImageID: int
    Url: str
    Writer: str
    Artist: str
    Colorist: str
    Letterer: str
    Editor: str
    _sum: 'comics_storiesSumAggregateOutput'
    _avg: 'comics_storiesAvgAggregateOutput'
    _min: 'comics_storiesMinAggregateOutput'
    _max: 'comics_storiesMaxAggregateOutput'
    _count: 'comics_storiesCountAggregateOutput'


class comics_storiesAvgAggregateOutput(TypedDict, total=False):
    """comics_stories output for aggregating averages"""
    ComicsStoryID: float
    ComicsSeriesID: float
    ImageID: float


class comics_storiesSumAggregateOutput(TypedDict, total=False):
    """comics_stories output for aggregating sums"""
    ComicsStoryID: int
    ComicsSeriesID: int
    ImageID: int


class comics_storiesScalarAggregateOutput(TypedDict, total=False):
    """comics_stories output including scalar fields"""
    ComicsStoryID: int
    Name: str
    ComicsSeriesID: int
    ImageID: int
    Url: str
    Writer: str
    Artist: str
    Colorist: str
    Letterer: str
    Editor: str


comics_storiesMinAggregateOutput = comics_storiesScalarAggregateOutput
comics_storiesMaxAggregateOutput = comics_storiesScalarAggregateOutput


class comics_storiesMaxAggregateInput(TypedDict, total=False):
    """comics_stories input for aggregating by max"""
    ComicsStoryID: bool
    Name: bool
    ComicsSeriesID: bool
    ImageID: bool
    Url: bool
    Writer: bool
    Artist: bool
    Colorist: bool
    Letterer: bool
    Editor: bool


class comics_storiesMinAggregateInput(TypedDict, total=False):
    """comics_stories input for aggregating by min"""
    ComicsStoryID: bool
    Name: bool
    ComicsSeriesID: bool
    ImageID: bool
    Url: bool
    Writer: bool
    Artist: bool
    Colorist: bool
    Letterer: bool
    Editor: bool


class comics_storiesNumberAggregateInput(TypedDict, total=False):
    """comics_stories input for aggregating numbers"""
    ComicsStoryID: bool
    ComicsSeriesID: bool
    ImageID: bool


comics_storiesAvgAggregateInput = comics_storiesNumberAggregateInput
comics_storiesSumAggregateInput = comics_storiesNumberAggregateInput


comics_storiesCountAggregateInput = TypedDict(
    'comics_storiesCountAggregateInput',
    {
        'ComicsStoryID': bool,
        'Name': bool,
        'ComicsSeriesID': bool,
        'ImageID': bool,
        'Url': bool,
        'Writer': bool,
        'Artist': bool,
        'Colorist': bool,
        'Letterer': bool,
        'Editor': bool,
        '_all': bool,
    },
    total=False,
)

comics_storiesCountAggregateOutput = TypedDict(
    'comics_storiesCountAggregateOutput',
    {
        'ComicsStoryID': int,
        'Name': int,
        'ComicsSeriesID': int,
        'ImageID': int,
        'Url': int,
        'Writer': int,
        'Artist': int,
        'Colorist': int,
        'Letterer': int,
        'Editor': int,
        '_all': int,
    },
    total=False,
)


comics_storiesKeys = Literal[
    'ComicsStoryID',
    'Name',
    'ComicsSeriesID',
    'ImageID',
    'Url',
    'Writer',
    'Artist',
    'Colorist',
    'Letterer',
    'Editor',
    'comics_series',
    'images',
    'comics_issues',
]
comics_storiesScalarFieldKeys = Literal[
    'ComicsStoryID',
    'Name',
    'ComicsSeriesID',
    'ImageID',
    'Url',
    'Writer',
    'Artist',
    'Colorist',
    'Letterer',
    'Editor',
]
comics_storiesScalarFieldKeysT = TypeVar('comics_storiesScalarFieldKeysT', bound=comics_storiesScalarFieldKeys)

comics_storiesRelationalFieldKeys = Literal[
        'comics_series',
        'images',
        'comics_issues',
    ]

# episodes types

class episodesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the episodes create method"""
    EpisodeID: int
    Season: Optional[int]
    Episode: Optional[int]
    OverallEpisode: Optional[int]
    StoryBy: Optional[str]
    WrittenBy: Optional[str]
    Storyboard: Optional[str]
    images: 'imagesCreateNestedWithoutRelationsInput'
    songs: 'songsCreateManyNestedWithoutRelationsInput'


class episodesCreateInput(episodesOptionalCreateInput):
    """Required arguments to the episodes create method"""
    Name: str
    Airdate: datetime.datetime
    Url: str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class episodesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the episodes create method, without relations"""
    EpisodeID: int
    Season: Optional[int]
    Episode: Optional[int]
    OverallEpisode: Optional[int]
    StoryBy: Optional[str]
    WrittenBy: Optional[str]
    Storyboard: Optional[str]


class episodesCreateWithoutRelationsInput(episodesOptionalCreateWithoutRelationsInput):
    """Required arguments to the episodes create method, without relations"""
    Name: str
    Airdate: datetime.datetime
    Url: str


class episodesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'episodesCreateWithoutRelationsInput'
    connect: 'episodesWhereUniqueInput'


class episodesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['episodesCreateWithoutRelationsInput', List['episodesCreateWithoutRelationsInput']]
    connect: Union['episodesWhereUniqueInput', List['episodesWhereUniqueInput']]


_episodesWhereUnique_EpisodeID_Input = TypedDict(
    '_episodesWhereUnique_EpisodeID_Input',
    {
        'EpisodeID': 'int',
    },
    total=True
)

_episodesWhereUnique_Name_Input = TypedDict(
    '_episodesWhereUnique_Name_Input',
    {
        'Name': 'str',
    },
    total=True
)

_episodesWhereUnique_OverallEpisode_Input = TypedDict(
    '_episodesWhereUnique_OverallEpisode_Input',
    {
        'OverallEpisode': 'int',
    },
    total=True
)

episodesWhereUniqueInput = Union[
    '_episodesWhereUnique_EpisodeID_Input',
    '_episodesWhereUnique_Name_Input',
    '_episodesWhereUnique_OverallEpisode_Input',
]


class episodesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    EpisodeID: Union[AtomicIntInput, int]
    Name: str
    Season: Optional[Union[AtomicIntInput, int]]
    Episode: Optional[Union[AtomicIntInput, int]]
    OverallEpisode: Optional[Union[AtomicIntInput, int]]
    Airdate: datetime.datetime
    StoryBy: Optional[str]
    WrittenBy: Optional[str]
    Storyboard: Optional[str]
    Url: str
    images: 'imagesUpdateOneWithoutRelationsInput'
    songs: 'songsUpdateManyWithoutRelationsInput'


class episodesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    EpisodeID: Union[AtomicIntInput, int]
    Name: str
    Season: Optional[Union[AtomicIntInput, int]]
    Episode: Optional[Union[AtomicIntInput, int]]
    OverallEpisode: Optional[Union[AtomicIntInput, int]]
    Airdate: datetime.datetime
    StoryBy: Optional[str]
    WrittenBy: Optional[str]
    Storyboard: Optional[str]
    Url: str


class episodesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['episodesCreateWithoutRelationsInput']
    connect: List['episodesWhereUniqueInput']
    set: List['episodesWhereUniqueInput']
    disconnect: List['episodesWhereUniqueInput']
    delete: List['episodesWhereUniqueInput']

    # TODO
    # update: List['episodesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['episodesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['episodesScalarWhereInput']
    # upsert: List['episodesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['episodesCreateOrConnectWithoutRelationsInput']


class episodesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'episodesCreateWithoutRelationsInput'
    connect: 'episodesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'episodesUpdateInput'
    # upsert: 'episodesUpsertWithoutRelationsInput'
    # connectOrCreate: 'episodesCreateOrConnectWithoutRelationsInput'


class episodesUpsertInput(TypedDict):
    create: 'episodesCreateInput'
    update: 'episodesUpdateInput'  # pyright: reportIncompatibleMethodOverride=false


_episodes_EpisodeID_OrderByInput = TypedDict(
    '_episodes_EpisodeID_OrderByInput',
    {
        'EpisodeID': 'SortOrder',
    },
    total=True
)

_episodes_Name_OrderByInput = TypedDict(
    '_episodes_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_episodes_ImageID_OrderByInput = TypedDict(
    '_episodes_ImageID_OrderByInput',
    {
        'ImageID': 'SortOrder',
    },
    total=True
)

_episodes_Season_OrderByInput = TypedDict(
    '_episodes_Season_OrderByInput',
    {
        'Season': 'SortOrder',
    },
    total=True
)

_episodes_Episode_OrderByInput = TypedDict(
    '_episodes_Episode_OrderByInput',
    {
        'Episode': 'SortOrder',
    },
    total=True
)

_episodes_OverallEpisode_OrderByInput = TypedDict(
    '_episodes_OverallEpisode_OrderByInput',
    {
        'OverallEpisode': 'SortOrder',
    },
    total=True
)

_episodes_Airdate_OrderByInput = TypedDict(
    '_episodes_Airdate_OrderByInput',
    {
        'Airdate': 'SortOrder',
    },
    total=True
)

_episodes_StoryBy_OrderByInput = TypedDict(
    '_episodes_StoryBy_OrderByInput',
    {
        'StoryBy': 'SortOrder',
    },
    total=True
)

_episodes_WrittenBy_OrderByInput = TypedDict(
    '_episodes_WrittenBy_OrderByInput',
    {
        'WrittenBy': 'SortOrder',
    },
    total=True
)

_episodes_Storyboard_OrderByInput = TypedDict(
    '_episodes_Storyboard_OrderByInput',
    {
        'Storyboard': 'SortOrder',
    },
    total=True
)

_episodes_Url_OrderByInput = TypedDict(
    '_episodes_Url_OrderByInput',
    {
        'Url': 'SortOrder',
    },
    total=True
)

episodesOrderByInput = Union[
    '_episodes_EpisodeID_OrderByInput',
    '_episodes_Name_OrderByInput',
    '_episodes_ImageID_OrderByInput',
    '_episodes_Season_OrderByInput',
    '_episodes_Episode_OrderByInput',
    '_episodes_OverallEpisode_OrderByInput',
    '_episodes_Airdate_OrderByInput',
    '_episodes_StoryBy_OrderByInput',
    '_episodes_WrittenBy_OrderByInput',
    '_episodes_Storyboard_OrderByInput',
    '_episodes_Url_OrderByInput',
]



# recursive episodes types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

episodesRelationFilter = TypedDict(
    'episodesRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class episodesListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class episodesInclude(TypedDict, total=False):
    """episodes relational arguments"""
    images: Union[bool, 'imagesArgsFromepisodes']
    songs: Union[bool, 'FindManysongsArgsFromepisodes']


    

class charactersIncludeFromepisodes(TypedDict, total=False):
    """Relational arguments for episodes"""


class charactersIncludeFromepisodesRecursive1(TypedDict, total=False):
    """Relational arguments for episodes"""


class charactersIncludeFromepisodesRecursive2(TypedDict, total=False):
    """Relational arguments for episodes"""


class charactersIncludeFromepisodesRecursive3(TypedDict, total=False):
    """Relational arguments for episodes"""


class charactersIncludeFromepisodesRecursive4(TypedDict, total=False):
    """Relational arguments for episodes"""

    

class charactersArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'charactersIncludeFromcharactersRecursive1'


class charactersArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'charactersIncludeFromcharactersRecursive2'


class charactersArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'charactersIncludeFromcharactersRecursive3'


class charactersArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'charactersIncludeFromcharactersRecursive4'


class charactersArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    
    

class FindManycharactersArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive1'


class FindManycharactersArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive2'


class FindManycharactersArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive3'


class FindManycharactersArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive4'


class FindManycharactersArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    
    

class comics_issuesIncludeFromepisodes(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'comics_storiesArgsFromepisodesRecursive1']


class comics_issuesIncludeFromepisodesRecursive1(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'comics_storiesArgsFromepisodesRecursive2']


class comics_issuesIncludeFromepisodesRecursive2(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'comics_storiesArgsFromepisodesRecursive3']


class comics_issuesIncludeFromepisodesRecursive3(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'comics_storiesArgsFromepisodesRecursive4']


class comics_issuesIncludeFromepisodesRecursive4(TypedDict, total=False):
    """Relational arguments for episodes"""

    

class comics_issuesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class comics_issuesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class comics_issuesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class comics_issuesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class comics_issuesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    
    

class FindManycomics_issuesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class FindManycomics_issuesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class FindManycomics_issuesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class FindManycomics_issuesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class FindManycomics_issuesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    
    

class comics_seriesIncludeFromepisodes(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromepisodesRecursive1']


class comics_seriesIncludeFromepisodesRecursive1(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromepisodesRecursive2']


class comics_seriesIncludeFromepisodesRecursive2(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromepisodesRecursive3']


class comics_seriesIncludeFromepisodesRecursive3(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromepisodesRecursive4']


class comics_seriesIncludeFromepisodesRecursive4(TypedDict, total=False):
    """Relational arguments for episodes"""

    

class comics_seriesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class comics_seriesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class comics_seriesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class comics_seriesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class comics_seriesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    
    

class FindManycomics_seriesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class FindManycomics_seriesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class FindManycomics_seriesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class FindManycomics_seriesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class FindManycomics_seriesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    
    

class comics_storiesIncludeFromepisodes(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_series: Union[bool, 'comics_seriesArgsFromepisodesRecursive1']
    images: Union[bool, 'imagesArgsFromepisodesRecursive1']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromepisodesRecursive1']


class comics_storiesIncludeFromepisodesRecursive1(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_series: Union[bool, 'comics_seriesArgsFromepisodesRecursive2']
    images: Union[bool, 'imagesArgsFromepisodesRecursive2']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromepisodesRecursive2']


class comics_storiesIncludeFromepisodesRecursive2(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_series: Union[bool, 'comics_seriesArgsFromepisodesRecursive3']
    images: Union[bool, 'imagesArgsFromepisodesRecursive3']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromepisodesRecursive3']


class comics_storiesIncludeFromepisodesRecursive3(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_series: Union[bool, 'comics_seriesArgsFromepisodesRecursive4']
    images: Union[bool, 'imagesArgsFromepisodesRecursive4']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromepisodesRecursive4']


class comics_storiesIncludeFromepisodesRecursive4(TypedDict, total=False):
    """Relational arguments for episodes"""

    

class comics_storiesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class comics_storiesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class comics_storiesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class comics_storiesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class comics_storiesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    
    

class FindManycomics_storiesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class FindManycomics_storiesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class FindManycomics_storiesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class FindManycomics_storiesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class FindManycomics_storiesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    
    

class episodesIncludeFromepisodes(TypedDict, total=False):
    """Relational arguments for episodes"""
    images: Union[bool, 'imagesArgsFromepisodesRecursive1']
    songs: Union[bool, 'FindManysongsArgsFromepisodesRecursive1']


class episodesIncludeFromepisodesRecursive1(TypedDict, total=False):
    """Relational arguments for episodes"""
    images: Union[bool, 'imagesArgsFromepisodesRecursive2']
    songs: Union[bool, 'FindManysongsArgsFromepisodesRecursive2']


class episodesIncludeFromepisodesRecursive2(TypedDict, total=False):
    """Relational arguments for episodes"""
    images: Union[bool, 'imagesArgsFromepisodesRecursive3']
    songs: Union[bool, 'FindManysongsArgsFromepisodesRecursive3']


class episodesIncludeFromepisodesRecursive3(TypedDict, total=False):
    """Relational arguments for episodes"""
    images: Union[bool, 'imagesArgsFromepisodesRecursive4']
    songs: Union[bool, 'FindManysongsArgsFromepisodesRecursive4']


class episodesIncludeFromepisodesRecursive4(TypedDict, total=False):
    """Relational arguments for episodes"""

    

class episodesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'episodesIncludeFromepisodesRecursive1'


class episodesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'episodesIncludeFromepisodesRecursive2'


class episodesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'episodesIncludeFromepisodesRecursive3'


class episodesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'episodesIncludeFromepisodesRecursive4'


class episodesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    
    

class FindManyepisodesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive1'


class FindManyepisodesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive2'


class FindManyepisodesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive3'


class FindManyepisodesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive4'


class FindManyepisodesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    
    

class imagesIncludeFromepisodes(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromepisodesRecursive1']
    episodes: Union[bool, 'FindManyepisodesArgsFromepisodesRecursive1']


class imagesIncludeFromepisodesRecursive1(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromepisodesRecursive2']
    episodes: Union[bool, 'FindManyepisodesArgsFromepisodesRecursive2']


class imagesIncludeFromepisodesRecursive2(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromepisodesRecursive3']
    episodes: Union[bool, 'FindManyepisodesArgsFromepisodesRecursive3']


class imagesIncludeFromepisodesRecursive3(TypedDict, total=False):
    """Relational arguments for episodes"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromepisodesRecursive4']
    episodes: Union[bool, 'FindManyepisodesArgsFromepisodesRecursive4']


class imagesIncludeFromepisodesRecursive4(TypedDict, total=False):
    """Relational arguments for episodes"""

    

class imagesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'imagesIncludeFromimagesRecursive1'


class imagesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'imagesIncludeFromimagesRecursive2'


class imagesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'imagesIncludeFromimagesRecursive3'


class imagesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'imagesIncludeFromimagesRecursive4'


class imagesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    
    

class FindManyimagesArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive1'


class FindManyimagesArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive2'


class FindManyimagesArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive3'


class FindManyimagesArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive4'


class FindManyimagesArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    
    

class kindsIncludeFromepisodes(TypedDict, total=False):
    """Relational arguments for episodes"""


class kindsIncludeFromepisodesRecursive1(TypedDict, total=False):
    """Relational arguments for episodes"""


class kindsIncludeFromepisodesRecursive2(TypedDict, total=False):
    """Relational arguments for episodes"""


class kindsIncludeFromepisodesRecursive3(TypedDict, total=False):
    """Relational arguments for episodes"""


class kindsIncludeFromepisodesRecursive4(TypedDict, total=False):
    """Relational arguments for episodes"""

    

class kindsArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'kindsIncludeFromkindsRecursive1'


class kindsArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'kindsIncludeFromkindsRecursive2'


class kindsArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'kindsIncludeFromkindsRecursive3'


class kindsArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'kindsIncludeFromkindsRecursive4'


class kindsArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    
    

class FindManykindsArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive1'


class FindManykindsArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive2'


class FindManykindsArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive3'


class FindManykindsArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive4'


class FindManykindsArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    
    

class songsIncludeFromepisodes(TypedDict, total=False):
    """Relational arguments for episodes"""
    episodes: Union[bool, 'episodesArgsFromepisodesRecursive1']


class songsIncludeFromepisodesRecursive1(TypedDict, total=False):
    """Relational arguments for episodes"""
    episodes: Union[bool, 'episodesArgsFromepisodesRecursive2']


class songsIncludeFromepisodesRecursive2(TypedDict, total=False):
    """Relational arguments for episodes"""
    episodes: Union[bool, 'episodesArgsFromepisodesRecursive3']


class songsIncludeFromepisodesRecursive3(TypedDict, total=False):
    """Relational arguments for episodes"""
    episodes: Union[bool, 'episodesArgsFromepisodesRecursive4']


class songsIncludeFromepisodesRecursive4(TypedDict, total=False):
    """Relational arguments for episodes"""

    

class songsArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'songsIncludeFromsongsRecursive1'


class songsArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'songsIncludeFromsongsRecursive2'


class songsArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'songsIncludeFromsongsRecursive3'


class songsArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    include: 'songsIncludeFromsongsRecursive4'


class songsArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    
    

class FindManysongsArgsFromepisodes(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive1'


class FindManysongsArgsFromepisodesRecursive1(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive2'


class FindManysongsArgsFromepisodesRecursive2(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive3'


class FindManysongsArgsFromepisodesRecursive3(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive4'


class FindManysongsArgsFromepisodesRecursive4(TypedDict, total=False):
    """Arguments for episodes"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    


FindManyepisodesArgs = FindManyepisodesArgsFromepisodes
FindFirstepisodesArgs = FindManyepisodesArgsFromepisodes


    

class episodesWhereInput(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ImageID: Union[int, 'types.IntFilter']
    Season: Union[int, 'types.IntFilter']
    Episode: Union[int, 'types.IntFilter']
    OverallEpisode: Union[int, 'types.IntFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeFilter']
    StoryBy: Union[str, 'types.StringFilter']
    WrittenBy: Union[str, 'types.StringFilter']
    Storyboard: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    images: 'imagesRelationFilter'
    songs: 'songsListRelationFilter'

    # should be noted that AND and NOT should be Union['episodesWhereInputRecursive1', List['episodesWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['episodesWhereInputRecursive1']
    OR: List['episodesWhereInputRecursive1']
    NOT: List['episodesWhereInputRecursive1']


class episodesWhereInputRecursive1(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ImageID: Union[int, 'types.IntFilter']
    Season: Union[int, 'types.IntFilter']
    Episode: Union[int, 'types.IntFilter']
    OverallEpisode: Union[int, 'types.IntFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeFilter']
    StoryBy: Union[str, 'types.StringFilter']
    WrittenBy: Union[str, 'types.StringFilter']
    Storyboard: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    images: 'imagesRelationFilter'
    songs: 'songsListRelationFilter'

    # should be noted that AND and NOT should be Union['episodesWhereInputRecursive2', List['episodesWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['episodesWhereInputRecursive2']
    OR: List['episodesWhereInputRecursive2']
    NOT: List['episodesWhereInputRecursive2']


class episodesWhereInputRecursive2(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ImageID: Union[int, 'types.IntFilter']
    Season: Union[int, 'types.IntFilter']
    Episode: Union[int, 'types.IntFilter']
    OverallEpisode: Union[int, 'types.IntFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeFilter']
    StoryBy: Union[str, 'types.StringFilter']
    WrittenBy: Union[str, 'types.StringFilter']
    Storyboard: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    images: 'imagesRelationFilter'
    songs: 'songsListRelationFilter'

    # should be noted that AND and NOT should be Union['episodesWhereInputRecursive3', List['episodesWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['episodesWhereInputRecursive3']
    OR: List['episodesWhereInputRecursive3']
    NOT: List['episodesWhereInputRecursive3']


class episodesWhereInputRecursive3(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ImageID: Union[int, 'types.IntFilter']
    Season: Union[int, 'types.IntFilter']
    Episode: Union[int, 'types.IntFilter']
    OverallEpisode: Union[int, 'types.IntFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeFilter']
    StoryBy: Union[str, 'types.StringFilter']
    WrittenBy: Union[str, 'types.StringFilter']
    Storyboard: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    images: 'imagesRelationFilter'
    songs: 'songsListRelationFilter'

    # should be noted that AND and NOT should be Union['episodesWhereInputRecursive4', List['episodesWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['episodesWhereInputRecursive4']
    OR: List['episodesWhereInputRecursive4']
    NOT: List['episodesWhereInputRecursive4']


class episodesWhereInputRecursive4(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    ImageID: Union[int, 'types.IntFilter']
    Season: Union[int, 'types.IntFilter']
    Episode: Union[int, 'types.IntFilter']
    OverallEpisode: Union[int, 'types.IntFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeFilter']
    StoryBy: Union[str, 'types.StringFilter']
    WrittenBy: Union[str, 'types.StringFilter']
    Storyboard: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    images: 'imagesRelationFilter'
    songs: 'songsListRelationFilter'



# aggregate episodes types


    

class episodesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Season: Union[int, 'types.IntWithAggregatesFilter']
    Episode: Union[int, 'types.IntWithAggregatesFilter']
    OverallEpisode: Union[int, 'types.IntWithAggregatesFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    StoryBy: Union[str, 'types.StringWithAggregatesFilter']
    WrittenBy: Union[str, 'types.StringWithAggregatesFilter']
    Storyboard: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['episodesScalarWhereWithAggregatesInputRecursive1']
    OR: List['episodesScalarWhereWithAggregatesInputRecursive1']
    NOT: List['episodesScalarWhereWithAggregatesInputRecursive1']


class episodesScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Season: Union[int, 'types.IntWithAggregatesFilter']
    Episode: Union[int, 'types.IntWithAggregatesFilter']
    OverallEpisode: Union[int, 'types.IntWithAggregatesFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    StoryBy: Union[str, 'types.StringWithAggregatesFilter']
    WrittenBy: Union[str, 'types.StringWithAggregatesFilter']
    Storyboard: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['episodesScalarWhereWithAggregatesInputRecursive2']
    OR: List['episodesScalarWhereWithAggregatesInputRecursive2']
    NOT: List['episodesScalarWhereWithAggregatesInputRecursive2']


class episodesScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Season: Union[int, 'types.IntWithAggregatesFilter']
    Episode: Union[int, 'types.IntWithAggregatesFilter']
    OverallEpisode: Union[int, 'types.IntWithAggregatesFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    StoryBy: Union[str, 'types.StringWithAggregatesFilter']
    WrittenBy: Union[str, 'types.StringWithAggregatesFilter']
    Storyboard: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['episodesScalarWhereWithAggregatesInputRecursive3']
    OR: List['episodesScalarWhereWithAggregatesInputRecursive3']
    NOT: List['episodesScalarWhereWithAggregatesInputRecursive3']


class episodesScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Season: Union[int, 'types.IntWithAggregatesFilter']
    Episode: Union[int, 'types.IntWithAggregatesFilter']
    OverallEpisode: Union[int, 'types.IntWithAggregatesFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    StoryBy: Union[str, 'types.StringWithAggregatesFilter']
    WrittenBy: Union[str, 'types.StringWithAggregatesFilter']
    Storyboard: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['episodesScalarWhereWithAggregatesInputRecursive4']
    OR: List['episodesScalarWhereWithAggregatesInputRecursive4']
    NOT: List['episodesScalarWhereWithAggregatesInputRecursive4']


class episodesScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """episodes arguments for searching"""
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Season: Union[int, 'types.IntWithAggregatesFilter']
    Episode: Union[int, 'types.IntWithAggregatesFilter']
    OverallEpisode: Union[int, 'types.IntWithAggregatesFilter']
    Airdate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    StoryBy: Union[str, 'types.StringWithAggregatesFilter']
    WrittenBy: Union[str, 'types.StringWithAggregatesFilter']
    Storyboard: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']



class episodesGroupByOutput(TypedDict, total=False):
    EpisodeID: int
    Name: str
    ImageID: int
    Season: int
    Episode: int
    OverallEpisode: int
    Airdate: datetime.datetime
    StoryBy: str
    WrittenBy: str
    Storyboard: str
    Url: str
    _sum: 'episodesSumAggregateOutput'
    _avg: 'episodesAvgAggregateOutput'
    _min: 'episodesMinAggregateOutput'
    _max: 'episodesMaxAggregateOutput'
    _count: 'episodesCountAggregateOutput'


class episodesAvgAggregateOutput(TypedDict, total=False):
    """episodes output for aggregating averages"""
    EpisodeID: float
    ImageID: float
    Season: float
    Episode: float
    OverallEpisode: float


class episodesSumAggregateOutput(TypedDict, total=False):
    """episodes output for aggregating sums"""
    EpisodeID: int
    ImageID: int
    Season: int
    Episode: int
    OverallEpisode: int


class episodesScalarAggregateOutput(TypedDict, total=False):
    """episodes output including scalar fields"""
    EpisodeID: int
    Name: str
    ImageID: int
    Season: int
    Episode: int
    OverallEpisode: int
    Airdate: datetime.datetime
    StoryBy: str
    WrittenBy: str
    Storyboard: str
    Url: str


episodesMinAggregateOutput = episodesScalarAggregateOutput
episodesMaxAggregateOutput = episodesScalarAggregateOutput


class episodesMaxAggregateInput(TypedDict, total=False):
    """episodes input for aggregating by max"""
    EpisodeID: bool
    Name: bool
    ImageID: bool
    Season: bool
    Episode: bool
    OverallEpisode: bool
    Airdate: bool
    StoryBy: bool
    WrittenBy: bool
    Storyboard: bool
    Url: bool


class episodesMinAggregateInput(TypedDict, total=False):
    """episodes input for aggregating by min"""
    EpisodeID: bool
    Name: bool
    ImageID: bool
    Season: bool
    Episode: bool
    OverallEpisode: bool
    Airdate: bool
    StoryBy: bool
    WrittenBy: bool
    Storyboard: bool
    Url: bool


class episodesNumberAggregateInput(TypedDict, total=False):
    """episodes input for aggregating numbers"""
    EpisodeID: bool
    ImageID: bool
    Season: bool
    Episode: bool
    OverallEpisode: bool


episodesAvgAggregateInput = episodesNumberAggregateInput
episodesSumAggregateInput = episodesNumberAggregateInput


episodesCountAggregateInput = TypedDict(
    'episodesCountAggregateInput',
    {
        'EpisodeID': bool,
        'Name': bool,
        'ImageID': bool,
        'Season': bool,
        'Episode': bool,
        'OverallEpisode': bool,
        'Airdate': bool,
        'StoryBy': bool,
        'WrittenBy': bool,
        'Storyboard': bool,
        'Url': bool,
        '_all': bool,
    },
    total=False,
)

episodesCountAggregateOutput = TypedDict(
    'episodesCountAggregateOutput',
    {
        'EpisodeID': int,
        'Name': int,
        'ImageID': int,
        'Season': int,
        'Episode': int,
        'OverallEpisode': int,
        'Airdate': int,
        'StoryBy': int,
        'WrittenBy': int,
        'Storyboard': int,
        'Url': int,
        '_all': int,
    },
    total=False,
)


episodesKeys = Literal[
    'EpisodeID',
    'Name',
    'ImageID',
    'Season',
    'Episode',
    'OverallEpisode',
    'Airdate',
    'StoryBy',
    'WrittenBy',
    'Storyboard',
    'Url',
    'images',
    'songs',
]
episodesScalarFieldKeys = Literal[
    'EpisodeID',
    'Name',
    'ImageID',
    'Season',
    'Episode',
    'OverallEpisode',
    'Airdate',
    'StoryBy',
    'WrittenBy',
    'Storyboard',
    'Url',
]
episodesScalarFieldKeysT = TypeVar('episodesScalarFieldKeysT', bound=episodesScalarFieldKeys)

episodesRelationalFieldKeys = Literal[
        'images',
        'songs',
    ]

# images types

class imagesOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the images create method"""
    ImageID: int
    Comment: Optional[str]
    comics_stories: 'comics_storiesCreateManyNestedWithoutRelationsInput'
    episodes: 'episodesCreateManyNestedWithoutRelationsInput'


class imagesCreateInput(imagesOptionalCreateInput):
    """Required arguments to the images create method"""
    Name: str
    Url: str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class imagesOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the images create method, without relations"""
    ImageID: int
    Comment: Optional[str]


class imagesCreateWithoutRelationsInput(imagesOptionalCreateWithoutRelationsInput):
    """Required arguments to the images create method, without relations"""
    Name: str
    Url: str


class imagesCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'imagesCreateWithoutRelationsInput'
    connect: 'imagesWhereUniqueInput'


class imagesCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['imagesCreateWithoutRelationsInput', List['imagesCreateWithoutRelationsInput']]
    connect: Union['imagesWhereUniqueInput', List['imagesWhereUniqueInput']]


_imagesWhereUnique_ImageID_Input = TypedDict(
    '_imagesWhereUnique_ImageID_Input',
    {
        'ImageID': 'int',
    },
    total=True
)

_imagesWhereUnique_Name_Input = TypedDict(
    '_imagesWhereUnique_Name_Input',
    {
        'Name': 'str',
    },
    total=True
)

imagesWhereUniqueInput = Union[
    '_imagesWhereUnique_ImageID_Input',
    '_imagesWhereUnique_Name_Input',
]


class imagesUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    ImageID: Union[AtomicIntInput, int]
    Name: str
    Url: str
    Comment: Optional[str]
    comics_stories: 'comics_storiesUpdateManyWithoutRelationsInput'
    episodes: 'episodesUpdateManyWithoutRelationsInput'


class imagesUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    ImageID: Union[AtomicIntInput, int]
    Name: str
    Url: str
    Comment: Optional[str]


class imagesUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['imagesCreateWithoutRelationsInput']
    connect: List['imagesWhereUniqueInput']
    set: List['imagesWhereUniqueInput']
    disconnect: List['imagesWhereUniqueInput']
    delete: List['imagesWhereUniqueInput']

    # TODO
    # update: List['imagesUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['imagesUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['imagesScalarWhereInput']
    # upsert: List['imagesUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['imagesCreateOrConnectWithoutRelationsInput']


class imagesUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'imagesCreateWithoutRelationsInput'
    connect: 'imagesWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'imagesUpdateInput'
    # upsert: 'imagesUpsertWithoutRelationsInput'
    # connectOrCreate: 'imagesCreateOrConnectWithoutRelationsInput'


class imagesUpsertInput(TypedDict):
    create: 'imagesCreateInput'
    update: 'imagesUpdateInput'  # pyright: reportIncompatibleMethodOverride=false


_images_ImageID_OrderByInput = TypedDict(
    '_images_ImageID_OrderByInput',
    {
        'ImageID': 'SortOrder',
    },
    total=True
)

_images_Name_OrderByInput = TypedDict(
    '_images_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_images_Url_OrderByInput = TypedDict(
    '_images_Url_OrderByInput',
    {
        'Url': 'SortOrder',
    },
    total=True
)

_images_Comment_OrderByInput = TypedDict(
    '_images_Comment_OrderByInput',
    {
        'Comment': 'SortOrder',
    },
    total=True
)

imagesOrderByInput = Union[
    '_images_ImageID_OrderByInput',
    '_images_Name_OrderByInput',
    '_images_Url_OrderByInput',
    '_images_Comment_OrderByInput',
]



# recursive images types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

imagesRelationFilter = TypedDict(
    'imagesRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class imagesListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class imagesInclude(TypedDict, total=False):
    """images relational arguments"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimages']
    episodes: Union[bool, 'FindManyepisodesArgsFromimages']


    

class charactersIncludeFromimages(TypedDict, total=False):
    """Relational arguments for images"""


class charactersIncludeFromimagesRecursive1(TypedDict, total=False):
    """Relational arguments for images"""


class charactersIncludeFromimagesRecursive2(TypedDict, total=False):
    """Relational arguments for images"""


class charactersIncludeFromimagesRecursive3(TypedDict, total=False):
    """Relational arguments for images"""


class charactersIncludeFromimagesRecursive4(TypedDict, total=False):
    """Relational arguments for images"""

    

class charactersArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    include: 'charactersIncludeFromcharactersRecursive1'


class charactersArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    include: 'charactersIncludeFromcharactersRecursive2'


class charactersArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    include: 'charactersIncludeFromcharactersRecursive3'


class charactersArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    include: 'charactersIncludeFromcharactersRecursive4'


class charactersArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    
    

class FindManycharactersArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive1'


class FindManycharactersArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive2'


class FindManycharactersArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive3'


class FindManycharactersArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive4'


class FindManycharactersArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    
    

class comics_issuesIncludeFromimages(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'comics_storiesArgsFromimagesRecursive1']


class comics_issuesIncludeFromimagesRecursive1(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'comics_storiesArgsFromimagesRecursive2']


class comics_issuesIncludeFromimagesRecursive2(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'comics_storiesArgsFromimagesRecursive3']


class comics_issuesIncludeFromimagesRecursive3(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'comics_storiesArgsFromimagesRecursive4']


class comics_issuesIncludeFromimagesRecursive4(TypedDict, total=False):
    """Relational arguments for images"""

    

class comics_issuesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class comics_issuesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class comics_issuesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class comics_issuesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class comics_issuesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    
    

class FindManycomics_issuesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class FindManycomics_issuesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class FindManycomics_issuesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class FindManycomics_issuesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class FindManycomics_issuesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    
    

class comics_seriesIncludeFromimages(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimagesRecursive1']


class comics_seriesIncludeFromimagesRecursive1(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimagesRecursive2']


class comics_seriesIncludeFromimagesRecursive2(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimagesRecursive3']


class comics_seriesIncludeFromimagesRecursive3(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimagesRecursive4']


class comics_seriesIncludeFromimagesRecursive4(TypedDict, total=False):
    """Relational arguments for images"""

    

class comics_seriesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class comics_seriesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class comics_seriesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class comics_seriesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class comics_seriesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    
    

class FindManycomics_seriesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class FindManycomics_seriesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class FindManycomics_seriesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class FindManycomics_seriesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class FindManycomics_seriesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    
    

class comics_storiesIncludeFromimages(TypedDict, total=False):
    """Relational arguments for images"""
    comics_series: Union[bool, 'comics_seriesArgsFromimagesRecursive1']
    images: Union[bool, 'imagesArgsFromimagesRecursive1']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromimagesRecursive1']


class comics_storiesIncludeFromimagesRecursive1(TypedDict, total=False):
    """Relational arguments for images"""
    comics_series: Union[bool, 'comics_seriesArgsFromimagesRecursive2']
    images: Union[bool, 'imagesArgsFromimagesRecursive2']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromimagesRecursive2']


class comics_storiesIncludeFromimagesRecursive2(TypedDict, total=False):
    """Relational arguments for images"""
    comics_series: Union[bool, 'comics_seriesArgsFromimagesRecursive3']
    images: Union[bool, 'imagesArgsFromimagesRecursive3']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromimagesRecursive3']


class comics_storiesIncludeFromimagesRecursive3(TypedDict, total=False):
    """Relational arguments for images"""
    comics_series: Union[bool, 'comics_seriesArgsFromimagesRecursive4']
    images: Union[bool, 'imagesArgsFromimagesRecursive4']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromimagesRecursive4']


class comics_storiesIncludeFromimagesRecursive4(TypedDict, total=False):
    """Relational arguments for images"""

    

class comics_storiesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class comics_storiesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class comics_storiesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class comics_storiesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class comics_storiesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    
    

class FindManycomics_storiesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class FindManycomics_storiesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class FindManycomics_storiesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class FindManycomics_storiesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class FindManycomics_storiesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    
    

class episodesIncludeFromimages(TypedDict, total=False):
    """Relational arguments for images"""
    images: Union[bool, 'imagesArgsFromimagesRecursive1']
    songs: Union[bool, 'FindManysongsArgsFromimagesRecursive1']


class episodesIncludeFromimagesRecursive1(TypedDict, total=False):
    """Relational arguments for images"""
    images: Union[bool, 'imagesArgsFromimagesRecursive2']
    songs: Union[bool, 'FindManysongsArgsFromimagesRecursive2']


class episodesIncludeFromimagesRecursive2(TypedDict, total=False):
    """Relational arguments for images"""
    images: Union[bool, 'imagesArgsFromimagesRecursive3']
    songs: Union[bool, 'FindManysongsArgsFromimagesRecursive3']


class episodesIncludeFromimagesRecursive3(TypedDict, total=False):
    """Relational arguments for images"""
    images: Union[bool, 'imagesArgsFromimagesRecursive4']
    songs: Union[bool, 'FindManysongsArgsFromimagesRecursive4']


class episodesIncludeFromimagesRecursive4(TypedDict, total=False):
    """Relational arguments for images"""

    

class episodesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    include: 'episodesIncludeFromepisodesRecursive1'


class episodesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    include: 'episodesIncludeFromepisodesRecursive2'


class episodesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    include: 'episodesIncludeFromepisodesRecursive3'


class episodesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    include: 'episodesIncludeFromepisodesRecursive4'


class episodesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    
    

class FindManyepisodesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive1'


class FindManyepisodesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive2'


class FindManyepisodesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive3'


class FindManyepisodesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive4'


class FindManyepisodesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    
    

class imagesIncludeFromimages(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimagesRecursive1']
    episodes: Union[bool, 'FindManyepisodesArgsFromimagesRecursive1']


class imagesIncludeFromimagesRecursive1(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimagesRecursive2']
    episodes: Union[bool, 'FindManyepisodesArgsFromimagesRecursive2']


class imagesIncludeFromimagesRecursive2(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimagesRecursive3']
    episodes: Union[bool, 'FindManyepisodesArgsFromimagesRecursive3']


class imagesIncludeFromimagesRecursive3(TypedDict, total=False):
    """Relational arguments for images"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromimagesRecursive4']
    episodes: Union[bool, 'FindManyepisodesArgsFromimagesRecursive4']


class imagesIncludeFromimagesRecursive4(TypedDict, total=False):
    """Relational arguments for images"""

    

class imagesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    include: 'imagesIncludeFromimagesRecursive1'


class imagesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    include: 'imagesIncludeFromimagesRecursive2'


class imagesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    include: 'imagesIncludeFromimagesRecursive3'


class imagesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    include: 'imagesIncludeFromimagesRecursive4'


class imagesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    
    

class FindManyimagesArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive1'


class FindManyimagesArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive2'


class FindManyimagesArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive3'


class FindManyimagesArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive4'


class FindManyimagesArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    
    

class kindsIncludeFromimages(TypedDict, total=False):
    """Relational arguments for images"""


class kindsIncludeFromimagesRecursive1(TypedDict, total=False):
    """Relational arguments for images"""


class kindsIncludeFromimagesRecursive2(TypedDict, total=False):
    """Relational arguments for images"""


class kindsIncludeFromimagesRecursive3(TypedDict, total=False):
    """Relational arguments for images"""


class kindsIncludeFromimagesRecursive4(TypedDict, total=False):
    """Relational arguments for images"""

    

class kindsArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    include: 'kindsIncludeFromkindsRecursive1'


class kindsArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    include: 'kindsIncludeFromkindsRecursive2'


class kindsArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    include: 'kindsIncludeFromkindsRecursive3'


class kindsArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    include: 'kindsIncludeFromkindsRecursive4'


class kindsArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    
    

class FindManykindsArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive1'


class FindManykindsArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive2'


class FindManykindsArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive3'


class FindManykindsArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive4'


class FindManykindsArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    
    

class songsIncludeFromimages(TypedDict, total=False):
    """Relational arguments for images"""
    episodes: Union[bool, 'episodesArgsFromimagesRecursive1']


class songsIncludeFromimagesRecursive1(TypedDict, total=False):
    """Relational arguments for images"""
    episodes: Union[bool, 'episodesArgsFromimagesRecursive2']


class songsIncludeFromimagesRecursive2(TypedDict, total=False):
    """Relational arguments for images"""
    episodes: Union[bool, 'episodesArgsFromimagesRecursive3']


class songsIncludeFromimagesRecursive3(TypedDict, total=False):
    """Relational arguments for images"""
    episodes: Union[bool, 'episodesArgsFromimagesRecursive4']


class songsIncludeFromimagesRecursive4(TypedDict, total=False):
    """Relational arguments for images"""

    

class songsArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    include: 'songsIncludeFromsongsRecursive1'


class songsArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    include: 'songsIncludeFromsongsRecursive2'


class songsArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    include: 'songsIncludeFromsongsRecursive3'


class songsArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    include: 'songsIncludeFromsongsRecursive4'


class songsArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    
    

class FindManysongsArgsFromimages(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive1'


class FindManysongsArgsFromimagesRecursive1(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive2'


class FindManysongsArgsFromimagesRecursive2(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive3'


class FindManysongsArgsFromimagesRecursive3(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive4'


class FindManysongsArgsFromimagesRecursive4(TypedDict, total=False):
    """Arguments for images"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    


FindManyimagesArgs = FindManyimagesArgsFromimages
FindFirstimagesArgs = FindManyimagesArgsFromimages


    

class imagesWhereInput(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    Comment: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'
    episodes: 'episodesListRelationFilter'

    # should be noted that AND and NOT should be Union['imagesWhereInputRecursive1', List['imagesWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['imagesWhereInputRecursive1']
    OR: List['imagesWhereInputRecursive1']
    NOT: List['imagesWhereInputRecursive1']


class imagesWhereInputRecursive1(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    Comment: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'
    episodes: 'episodesListRelationFilter'

    # should be noted that AND and NOT should be Union['imagesWhereInputRecursive2', List['imagesWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['imagesWhereInputRecursive2']
    OR: List['imagesWhereInputRecursive2']
    NOT: List['imagesWhereInputRecursive2']


class imagesWhereInputRecursive2(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    Comment: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'
    episodes: 'episodesListRelationFilter'

    # should be noted that AND and NOT should be Union['imagesWhereInputRecursive3', List['imagesWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['imagesWhereInputRecursive3']
    OR: List['imagesWhereInputRecursive3']
    NOT: List['imagesWhereInputRecursive3']


class imagesWhereInputRecursive3(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    Comment: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'
    episodes: 'episodesListRelationFilter'

    # should be noted that AND and NOT should be Union['imagesWhereInputRecursive4', List['imagesWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['imagesWhereInputRecursive4']
    OR: List['imagesWhereInputRecursive4']
    NOT: List['imagesWhereInputRecursive4']


class imagesWhereInputRecursive4(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    Comment: Union[str, 'types.StringFilter']
    comics_stories: 'comics_storiesListRelationFilter'
    episodes: 'episodesListRelationFilter'



# aggregate images types


    

class imagesScalarWhereWithAggregatesInput(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Comment: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['imagesScalarWhereWithAggregatesInputRecursive1']
    OR: List['imagesScalarWhereWithAggregatesInputRecursive1']
    NOT: List['imagesScalarWhereWithAggregatesInputRecursive1']


class imagesScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Comment: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['imagesScalarWhereWithAggregatesInputRecursive2']
    OR: List['imagesScalarWhereWithAggregatesInputRecursive2']
    NOT: List['imagesScalarWhereWithAggregatesInputRecursive2']


class imagesScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Comment: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['imagesScalarWhereWithAggregatesInputRecursive3']
    OR: List['imagesScalarWhereWithAggregatesInputRecursive3']
    NOT: List['imagesScalarWhereWithAggregatesInputRecursive3']


class imagesScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Comment: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['imagesScalarWhereWithAggregatesInputRecursive4']
    OR: List['imagesScalarWhereWithAggregatesInputRecursive4']
    NOT: List['imagesScalarWhereWithAggregatesInputRecursive4']


class imagesScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """images arguments for searching"""
    ImageID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']
    Comment: Union[str, 'types.StringWithAggregatesFilter']



class imagesGroupByOutput(TypedDict, total=False):
    ImageID: int
    Name: str
    Url: str
    Comment: str
    _sum: 'imagesSumAggregateOutput'
    _avg: 'imagesAvgAggregateOutput'
    _min: 'imagesMinAggregateOutput'
    _max: 'imagesMaxAggregateOutput'
    _count: 'imagesCountAggregateOutput'


class imagesAvgAggregateOutput(TypedDict, total=False):
    """images output for aggregating averages"""
    ImageID: float


class imagesSumAggregateOutput(TypedDict, total=False):
    """images output for aggregating sums"""
    ImageID: int


class imagesScalarAggregateOutput(TypedDict, total=False):
    """images output including scalar fields"""
    ImageID: int
    Name: str
    Url: str
    Comment: str


imagesMinAggregateOutput = imagesScalarAggregateOutput
imagesMaxAggregateOutput = imagesScalarAggregateOutput


class imagesMaxAggregateInput(TypedDict, total=False):
    """images input for aggregating by max"""
    ImageID: bool
    Name: bool
    Url: bool
    Comment: bool


class imagesMinAggregateInput(TypedDict, total=False):
    """images input for aggregating by min"""
    ImageID: bool
    Name: bool
    Url: bool
    Comment: bool


class imagesNumberAggregateInput(TypedDict, total=False):
    """images input for aggregating numbers"""
    ImageID: bool


imagesAvgAggregateInput = imagesNumberAggregateInput
imagesSumAggregateInput = imagesNumberAggregateInput


imagesCountAggregateInput = TypedDict(
    'imagesCountAggregateInput',
    {
        'ImageID': bool,
        'Name': bool,
        'Url': bool,
        'Comment': bool,
        '_all': bool,
    },
    total=False,
)

imagesCountAggregateOutput = TypedDict(
    'imagesCountAggregateOutput',
    {
        'ImageID': int,
        'Name': int,
        'Url': int,
        'Comment': int,
        '_all': int,
    },
    total=False,
)


imagesKeys = Literal[
    'ImageID',
    'Name',
    'Url',
    'Comment',
    'comics_stories',
    'episodes',
]
imagesScalarFieldKeys = Literal[
    'ImageID',
    'Name',
    'Url',
    'Comment',
]
imagesScalarFieldKeysT = TypeVar('imagesScalarFieldKeysT', bound=imagesScalarFieldKeys)

imagesRelationalFieldKeys = Literal[
        'comics_stories',
        'episodes',
    ]

# kinds types

class kindsOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the kinds create method"""
    KindID: int
    Url: Optional[str]


class kindsCreateInput(kindsOptionalCreateInput):
    """Required arguments to the kinds create method"""
    Name: str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class kindsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the kinds create method, without relations"""
    KindID: int
    Url: Optional[str]


class kindsCreateWithoutRelationsInput(kindsOptionalCreateWithoutRelationsInput):
    """Required arguments to the kinds create method, without relations"""
    Name: str


class kindsCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'kindsCreateWithoutRelationsInput'
    connect: 'kindsWhereUniqueInput'


class kindsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['kindsCreateWithoutRelationsInput', List['kindsCreateWithoutRelationsInput']]
    connect: Union['kindsWhereUniqueInput', List['kindsWhereUniqueInput']]


_kindsWhereUnique_KindID_Input = TypedDict(
    '_kindsWhereUnique_KindID_Input',
    {
        'KindID': 'int',
    },
    total=True
)

_kindsWhereUnique_Url_Input = TypedDict(
    '_kindsWhereUnique_Url_Input',
    {
        'Url': 'str',
    },
    total=True
)

kindsWhereUniqueInput = Union[
    '_kindsWhereUnique_KindID_Input',
    '_kindsWhereUnique_Url_Input',
]


class kindsUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    KindID: Union[AtomicIntInput, int]
    Name: str
    Url: Optional[str]


class kindsUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    KindID: Union[AtomicIntInput, int]
    Name: str
    Url: Optional[str]


class kindsUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['kindsCreateWithoutRelationsInput']
    connect: List['kindsWhereUniqueInput']
    set: List['kindsWhereUniqueInput']
    disconnect: List['kindsWhereUniqueInput']
    delete: List['kindsWhereUniqueInput']

    # TODO
    # update: List['kindsUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['kindsUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['kindsScalarWhereInput']
    # upsert: List['kindsUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['kindsCreateOrConnectWithoutRelationsInput']


class kindsUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'kindsCreateWithoutRelationsInput'
    connect: 'kindsWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'kindsUpdateInput'
    # upsert: 'kindsUpsertWithoutRelationsInput'
    # connectOrCreate: 'kindsCreateOrConnectWithoutRelationsInput'


class kindsUpsertInput(TypedDict):
    create: 'kindsCreateInput'
    update: 'kindsUpdateInput'  # pyright: reportIncompatibleMethodOverride=false


_kinds_KindID_OrderByInput = TypedDict(
    '_kinds_KindID_OrderByInput',
    {
        'KindID': 'SortOrder',
    },
    total=True
)

_kinds_Name_OrderByInput = TypedDict(
    '_kinds_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_kinds_Url_OrderByInput = TypedDict(
    '_kinds_Url_OrderByInput',
    {
        'Url': 'SortOrder',
    },
    total=True
)

kindsOrderByInput = Union[
    '_kinds_KindID_OrderByInput',
    '_kinds_Name_OrderByInput',
    '_kinds_Url_OrderByInput',
]



# recursive kinds types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

kindsRelationFilter = TypedDict(
    'kindsRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class kindsListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class kindsInclude(TypedDict, total=False):
    """kinds relational arguments"""


    

class charactersIncludeFromkinds(TypedDict, total=False):
    """Relational arguments for kinds"""


class charactersIncludeFromkindsRecursive1(TypedDict, total=False):
    """Relational arguments for kinds"""


class charactersIncludeFromkindsRecursive2(TypedDict, total=False):
    """Relational arguments for kinds"""


class charactersIncludeFromkindsRecursive3(TypedDict, total=False):
    """Relational arguments for kinds"""


class charactersIncludeFromkindsRecursive4(TypedDict, total=False):
    """Relational arguments for kinds"""

    

class charactersArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'charactersIncludeFromcharactersRecursive1'


class charactersArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'charactersIncludeFromcharactersRecursive2'


class charactersArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'charactersIncludeFromcharactersRecursive3'


class charactersArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'charactersIncludeFromcharactersRecursive4'


class charactersArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    
    

class FindManycharactersArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive1'


class FindManycharactersArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive2'


class FindManycharactersArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive3'


class FindManycharactersArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive4'


class FindManycharactersArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    
    

class comics_issuesIncludeFromkinds(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'comics_storiesArgsFromkindsRecursive1']


class comics_issuesIncludeFromkindsRecursive1(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'comics_storiesArgsFromkindsRecursive2']


class comics_issuesIncludeFromkindsRecursive2(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'comics_storiesArgsFromkindsRecursive3']


class comics_issuesIncludeFromkindsRecursive3(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'comics_storiesArgsFromkindsRecursive4']


class comics_issuesIncludeFromkindsRecursive4(TypedDict, total=False):
    """Relational arguments for kinds"""

    

class comics_issuesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class comics_issuesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class comics_issuesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class comics_issuesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class comics_issuesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    
    

class FindManycomics_issuesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class FindManycomics_issuesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class FindManycomics_issuesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class FindManycomics_issuesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class FindManycomics_issuesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    
    

class comics_seriesIncludeFromkinds(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromkindsRecursive1']


class comics_seriesIncludeFromkindsRecursive1(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromkindsRecursive2']


class comics_seriesIncludeFromkindsRecursive2(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromkindsRecursive3']


class comics_seriesIncludeFromkindsRecursive3(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromkindsRecursive4']


class comics_seriesIncludeFromkindsRecursive4(TypedDict, total=False):
    """Relational arguments for kinds"""

    

class comics_seriesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class comics_seriesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class comics_seriesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class comics_seriesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class comics_seriesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    
    

class FindManycomics_seriesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class FindManycomics_seriesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class FindManycomics_seriesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class FindManycomics_seriesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class FindManycomics_seriesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    
    

class comics_storiesIncludeFromkinds(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_series: Union[bool, 'comics_seriesArgsFromkindsRecursive1']
    images: Union[bool, 'imagesArgsFromkindsRecursive1']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromkindsRecursive1']


class comics_storiesIncludeFromkindsRecursive1(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_series: Union[bool, 'comics_seriesArgsFromkindsRecursive2']
    images: Union[bool, 'imagesArgsFromkindsRecursive2']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromkindsRecursive2']


class comics_storiesIncludeFromkindsRecursive2(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_series: Union[bool, 'comics_seriesArgsFromkindsRecursive3']
    images: Union[bool, 'imagesArgsFromkindsRecursive3']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromkindsRecursive3']


class comics_storiesIncludeFromkindsRecursive3(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_series: Union[bool, 'comics_seriesArgsFromkindsRecursive4']
    images: Union[bool, 'imagesArgsFromkindsRecursive4']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromkindsRecursive4']


class comics_storiesIncludeFromkindsRecursive4(TypedDict, total=False):
    """Relational arguments for kinds"""

    

class comics_storiesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class comics_storiesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class comics_storiesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class comics_storiesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class comics_storiesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    
    

class FindManycomics_storiesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class FindManycomics_storiesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class FindManycomics_storiesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class FindManycomics_storiesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class FindManycomics_storiesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    
    

class episodesIncludeFromkinds(TypedDict, total=False):
    """Relational arguments for kinds"""
    images: Union[bool, 'imagesArgsFromkindsRecursive1']
    songs: Union[bool, 'FindManysongsArgsFromkindsRecursive1']


class episodesIncludeFromkindsRecursive1(TypedDict, total=False):
    """Relational arguments for kinds"""
    images: Union[bool, 'imagesArgsFromkindsRecursive2']
    songs: Union[bool, 'FindManysongsArgsFromkindsRecursive2']


class episodesIncludeFromkindsRecursive2(TypedDict, total=False):
    """Relational arguments for kinds"""
    images: Union[bool, 'imagesArgsFromkindsRecursive3']
    songs: Union[bool, 'FindManysongsArgsFromkindsRecursive3']


class episodesIncludeFromkindsRecursive3(TypedDict, total=False):
    """Relational arguments for kinds"""
    images: Union[bool, 'imagesArgsFromkindsRecursive4']
    songs: Union[bool, 'FindManysongsArgsFromkindsRecursive4']


class episodesIncludeFromkindsRecursive4(TypedDict, total=False):
    """Relational arguments for kinds"""

    

class episodesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'episodesIncludeFromepisodesRecursive1'


class episodesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'episodesIncludeFromepisodesRecursive2'


class episodesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'episodesIncludeFromepisodesRecursive3'


class episodesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'episodesIncludeFromepisodesRecursive4'


class episodesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    
    

class FindManyepisodesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive1'


class FindManyepisodesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive2'


class FindManyepisodesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive3'


class FindManyepisodesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive4'


class FindManyepisodesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    
    

class imagesIncludeFromkinds(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromkindsRecursive1']
    episodes: Union[bool, 'FindManyepisodesArgsFromkindsRecursive1']


class imagesIncludeFromkindsRecursive1(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromkindsRecursive2']
    episodes: Union[bool, 'FindManyepisodesArgsFromkindsRecursive2']


class imagesIncludeFromkindsRecursive2(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromkindsRecursive3']
    episodes: Union[bool, 'FindManyepisodesArgsFromkindsRecursive3']


class imagesIncludeFromkindsRecursive3(TypedDict, total=False):
    """Relational arguments for kinds"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromkindsRecursive4']
    episodes: Union[bool, 'FindManyepisodesArgsFromkindsRecursive4']


class imagesIncludeFromkindsRecursive4(TypedDict, total=False):
    """Relational arguments for kinds"""

    

class imagesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'imagesIncludeFromimagesRecursive1'


class imagesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'imagesIncludeFromimagesRecursive2'


class imagesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'imagesIncludeFromimagesRecursive3'


class imagesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'imagesIncludeFromimagesRecursive4'


class imagesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    
    

class FindManyimagesArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive1'


class FindManyimagesArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive2'


class FindManyimagesArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive3'


class FindManyimagesArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive4'


class FindManyimagesArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    
    

class kindsIncludeFromkinds(TypedDict, total=False):
    """Relational arguments for kinds"""


class kindsIncludeFromkindsRecursive1(TypedDict, total=False):
    """Relational arguments for kinds"""


class kindsIncludeFromkindsRecursive2(TypedDict, total=False):
    """Relational arguments for kinds"""


class kindsIncludeFromkindsRecursive3(TypedDict, total=False):
    """Relational arguments for kinds"""


class kindsIncludeFromkindsRecursive4(TypedDict, total=False):
    """Relational arguments for kinds"""

    

class kindsArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'kindsIncludeFromkindsRecursive1'


class kindsArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'kindsIncludeFromkindsRecursive2'


class kindsArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'kindsIncludeFromkindsRecursive3'


class kindsArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'kindsIncludeFromkindsRecursive4'


class kindsArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    
    

class FindManykindsArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive1'


class FindManykindsArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive2'


class FindManykindsArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive3'


class FindManykindsArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive4'


class FindManykindsArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    
    

class songsIncludeFromkinds(TypedDict, total=False):
    """Relational arguments for kinds"""
    episodes: Union[bool, 'episodesArgsFromkindsRecursive1']


class songsIncludeFromkindsRecursive1(TypedDict, total=False):
    """Relational arguments for kinds"""
    episodes: Union[bool, 'episodesArgsFromkindsRecursive2']


class songsIncludeFromkindsRecursive2(TypedDict, total=False):
    """Relational arguments for kinds"""
    episodes: Union[bool, 'episodesArgsFromkindsRecursive3']


class songsIncludeFromkindsRecursive3(TypedDict, total=False):
    """Relational arguments for kinds"""
    episodes: Union[bool, 'episodesArgsFromkindsRecursive4']


class songsIncludeFromkindsRecursive4(TypedDict, total=False):
    """Relational arguments for kinds"""

    

class songsArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'songsIncludeFromsongsRecursive1'


class songsArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'songsIncludeFromsongsRecursive2'


class songsArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'songsIncludeFromsongsRecursive3'


class songsArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    include: 'songsIncludeFromsongsRecursive4'


class songsArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    
    

class FindManysongsArgsFromkinds(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive1'


class FindManysongsArgsFromkindsRecursive1(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive2'


class FindManysongsArgsFromkindsRecursive2(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive3'


class FindManysongsArgsFromkindsRecursive3(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive4'


class FindManysongsArgsFromkindsRecursive4(TypedDict, total=False):
    """Arguments for kinds"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    


FindManykindsArgs = FindManykindsArgsFromkinds
FindFirstkindsArgs = FindManykindsArgsFromkinds


    

class kindsWhereInput(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['kindsWhereInputRecursive1', List['kindsWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['kindsWhereInputRecursive1']
    OR: List['kindsWhereInputRecursive1']
    NOT: List['kindsWhereInputRecursive1']


class kindsWhereInputRecursive1(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['kindsWhereInputRecursive2', List['kindsWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['kindsWhereInputRecursive2']
    OR: List['kindsWhereInputRecursive2']
    NOT: List['kindsWhereInputRecursive2']


class kindsWhereInputRecursive2(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['kindsWhereInputRecursive3', List['kindsWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['kindsWhereInputRecursive3']
    OR: List['kindsWhereInputRecursive3']
    NOT: List['kindsWhereInputRecursive3']


class kindsWhereInputRecursive3(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['kindsWhereInputRecursive4', List['kindsWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['kindsWhereInputRecursive4']
    OR: List['kindsWhereInputRecursive4']
    NOT: List['kindsWhereInputRecursive4']


class kindsWhereInputRecursive4(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']



# aggregate kinds types


    

class kindsScalarWhereWithAggregatesInput(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['kindsScalarWhereWithAggregatesInputRecursive1']
    OR: List['kindsScalarWhereWithAggregatesInputRecursive1']
    NOT: List['kindsScalarWhereWithAggregatesInputRecursive1']


class kindsScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['kindsScalarWhereWithAggregatesInputRecursive2']
    OR: List['kindsScalarWhereWithAggregatesInputRecursive2']
    NOT: List['kindsScalarWhereWithAggregatesInputRecursive2']


class kindsScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['kindsScalarWhereWithAggregatesInputRecursive3']
    OR: List['kindsScalarWhereWithAggregatesInputRecursive3']
    NOT: List['kindsScalarWhereWithAggregatesInputRecursive3']


class kindsScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['kindsScalarWhereWithAggregatesInputRecursive4']
    OR: List['kindsScalarWhereWithAggregatesInputRecursive4']
    NOT: List['kindsScalarWhereWithAggregatesInputRecursive4']


class kindsScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """kinds arguments for searching"""
    KindID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']



class kindsGroupByOutput(TypedDict, total=False):
    KindID: int
    Name: str
    Url: str
    _sum: 'kindsSumAggregateOutput'
    _avg: 'kindsAvgAggregateOutput'
    _min: 'kindsMinAggregateOutput'
    _max: 'kindsMaxAggregateOutput'
    _count: 'kindsCountAggregateOutput'


class kindsAvgAggregateOutput(TypedDict, total=False):
    """kinds output for aggregating averages"""
    KindID: float


class kindsSumAggregateOutput(TypedDict, total=False):
    """kinds output for aggregating sums"""
    KindID: int


class kindsScalarAggregateOutput(TypedDict, total=False):
    """kinds output including scalar fields"""
    KindID: int
    Name: str
    Url: str


kindsMinAggregateOutput = kindsScalarAggregateOutput
kindsMaxAggregateOutput = kindsScalarAggregateOutput


class kindsMaxAggregateInput(TypedDict, total=False):
    """kinds input for aggregating by max"""
    KindID: bool
    Name: bool
    Url: bool


class kindsMinAggregateInput(TypedDict, total=False):
    """kinds input for aggregating by min"""
    KindID: bool
    Name: bool
    Url: bool


class kindsNumberAggregateInput(TypedDict, total=False):
    """kinds input for aggregating numbers"""
    KindID: bool


kindsAvgAggregateInput = kindsNumberAggregateInput
kindsSumAggregateInput = kindsNumberAggregateInput


kindsCountAggregateInput = TypedDict(
    'kindsCountAggregateInput',
    {
        'KindID': bool,
        'Name': bool,
        'Url': bool,
        '_all': bool,
    },
    total=False,
)

kindsCountAggregateOutput = TypedDict(
    'kindsCountAggregateOutput',
    {
        'KindID': int,
        'Name': int,
        'Url': int,
        '_all': int,
    },
    total=False,
)


kindsKeys = Literal[
    'KindID',
    'Name',
    'Url',
]
kindsScalarFieldKeys = Literal[
    'KindID',
    'Name',
    'Url',
]
kindsScalarFieldKeysT = TypeVar('kindsScalarFieldKeysT', bound=kindsScalarFieldKeys)

kindsRelationalFieldKeys = _NoneType

# songs types

class songsOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the songs create method"""
    SongID: int
    MusicBy: Optional[str]
    LyricsBy: Optional[str]
    KeySignatures: Optional[str]
    episodes: 'episodesCreateNestedWithoutRelationsInput'


class songsCreateInput(songsOptionalCreateInput):
    """Required arguments to the songs create method"""
    Name: str
    VideoUrl: str
    Length: str
    Url: str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class songsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the songs create method, without relations"""
    SongID: int
    MusicBy: Optional[str]
    LyricsBy: Optional[str]
    KeySignatures: Optional[str]


class songsCreateWithoutRelationsInput(songsOptionalCreateWithoutRelationsInput):
    """Required arguments to the songs create method, without relations"""
    Name: str
    VideoUrl: str
    Length: str
    Url: str


class songsCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'songsCreateWithoutRelationsInput'
    connect: 'songsWhereUniqueInput'


class songsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['songsCreateWithoutRelationsInput', List['songsCreateWithoutRelationsInput']]
    connect: Union['songsWhereUniqueInput', List['songsWhereUniqueInput']]


_songsWhereUnique_SongID_Input = TypedDict(
    '_songsWhereUnique_SongID_Input',
    {
        'SongID': 'int',
    },
    total=True
)

_songsWhereUnique_Name_Input = TypedDict(
    '_songsWhereUnique_Name_Input',
    {
        'Name': 'str',
    },
    total=True
)

songsWhereUniqueInput = Union[
    '_songsWhereUnique_SongID_Input',
    '_songsWhereUnique_Name_Input',
]


class songsUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    SongID: Union[AtomicIntInput, int]
    Name: str
    VideoUrl: str
    Length: str
    MusicBy: Optional[str]
    LyricsBy: Optional[str]
    KeySignatures: Optional[str]
    Url: str
    episodes: 'episodesUpdateOneWithoutRelationsInput'


class songsUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    SongID: Union[AtomicIntInput, int]
    Name: str
    VideoUrl: str
    Length: str
    MusicBy: Optional[str]
    LyricsBy: Optional[str]
    KeySignatures: Optional[str]
    Url: str


class songsUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['songsCreateWithoutRelationsInput']
    connect: List['songsWhereUniqueInput']
    set: List['songsWhereUniqueInput']
    disconnect: List['songsWhereUniqueInput']
    delete: List['songsWhereUniqueInput']

    # TODO
    # update: List['songsUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['songsUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['songsScalarWhereInput']
    # upsert: List['songsUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['songsCreateOrConnectWithoutRelationsInput']


class songsUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'songsCreateWithoutRelationsInput'
    connect: 'songsWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'songsUpdateInput'
    # upsert: 'songsUpsertWithoutRelationsInput'
    # connectOrCreate: 'songsCreateOrConnectWithoutRelationsInput'


class songsUpsertInput(TypedDict):
    create: 'songsCreateInput'
    update: 'songsUpdateInput'  # pyright: reportIncompatibleMethodOverride=false


_songs_SongID_OrderByInput = TypedDict(
    '_songs_SongID_OrderByInput',
    {
        'SongID': 'SortOrder',
    },
    total=True
)

_songs_Name_OrderByInput = TypedDict(
    '_songs_Name_OrderByInput',
    {
        'Name': 'SortOrder',
    },
    total=True
)

_songs_EpisodeID_OrderByInput = TypedDict(
    '_songs_EpisodeID_OrderByInput',
    {
        'EpisodeID': 'SortOrder',
    },
    total=True
)

_songs_VideoUrl_OrderByInput = TypedDict(
    '_songs_VideoUrl_OrderByInput',
    {
        'VideoUrl': 'SortOrder',
    },
    total=True
)

_songs_Length_OrderByInput = TypedDict(
    '_songs_Length_OrderByInput',
    {
        'Length': 'SortOrder',
    },
    total=True
)

_songs_MusicBy_OrderByInput = TypedDict(
    '_songs_MusicBy_OrderByInput',
    {
        'MusicBy': 'SortOrder',
    },
    total=True
)

_songs_LyricsBy_OrderByInput = TypedDict(
    '_songs_LyricsBy_OrderByInput',
    {
        'LyricsBy': 'SortOrder',
    },
    total=True
)

_songs_KeySignatures_OrderByInput = TypedDict(
    '_songs_KeySignatures_OrderByInput',
    {
        'KeySignatures': 'SortOrder',
    },
    total=True
)

_songs_Url_OrderByInput = TypedDict(
    '_songs_Url_OrderByInput',
    {
        'Url': 'SortOrder',
    },
    total=True
)

songsOrderByInput = Union[
    '_songs_SongID_OrderByInput',
    '_songs_Name_OrderByInput',
    '_songs_EpisodeID_OrderByInput',
    '_songs_VideoUrl_OrderByInput',
    '_songs_Length_OrderByInput',
    '_songs_MusicBy_OrderByInput',
    '_songs_LyricsBy_OrderByInput',
    '_songs_KeySignatures_OrderByInput',
    '_songs_Url_OrderByInput',
]



# recursive songs types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

songsRelationFilter = TypedDict(
    'songsRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class songsListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class songsInclude(TypedDict, total=False):
    """songs relational arguments"""
    episodes: Union[bool, 'episodesArgsFromsongs']


    

class charactersIncludeFromsongs(TypedDict, total=False):
    """Relational arguments for songs"""


class charactersIncludeFromsongsRecursive1(TypedDict, total=False):
    """Relational arguments for songs"""


class charactersIncludeFromsongsRecursive2(TypedDict, total=False):
    """Relational arguments for songs"""


class charactersIncludeFromsongsRecursive3(TypedDict, total=False):
    """Relational arguments for songs"""


class charactersIncludeFromsongsRecursive4(TypedDict, total=False):
    """Relational arguments for songs"""

    

class charactersArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    include: 'charactersIncludeFromcharactersRecursive1'


class charactersArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    include: 'charactersIncludeFromcharactersRecursive2'


class charactersArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    include: 'charactersIncludeFromcharactersRecursive3'


class charactersArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    include: 'charactersIncludeFromcharactersRecursive4'


class charactersArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    
    

class FindManycharactersArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive1'


class FindManycharactersArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive2'


class FindManycharactersArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive3'


class FindManycharactersArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    include: 'charactersIncludeFromcharactersRecursive4'


class FindManycharactersArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['charactersOrderByInput', List['charactersOrderByInput']]
    where: 'charactersWhereInput'
    cursor: 'charactersWhereUniqueInput'
    
    

class comics_issuesIncludeFromsongs(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'comics_storiesArgsFromsongsRecursive1']


class comics_issuesIncludeFromsongsRecursive1(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'comics_storiesArgsFromsongsRecursive2']


class comics_issuesIncludeFromsongsRecursive2(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'comics_storiesArgsFromsongsRecursive3']


class comics_issuesIncludeFromsongsRecursive3(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'comics_storiesArgsFromsongsRecursive4']


class comics_issuesIncludeFromsongsRecursive4(TypedDict, total=False):
    """Relational arguments for songs"""

    

class comics_issuesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class comics_issuesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class comics_issuesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class comics_issuesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class comics_issuesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    
    

class FindManycomics_issuesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive1'


class FindManycomics_issuesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive2'


class FindManycomics_issuesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive3'


class FindManycomics_issuesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    include: 'comics_issuesIncludeFromcomics_issuesRecursive4'


class FindManycomics_issuesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_issuesOrderByInput', List['comics_issuesOrderByInput']]
    where: 'comics_issuesWhereInput'
    cursor: 'comics_issuesWhereUniqueInput'
    
    

class comics_seriesIncludeFromsongs(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromsongsRecursive1']


class comics_seriesIncludeFromsongsRecursive1(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromsongsRecursive2']


class comics_seriesIncludeFromsongsRecursive2(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromsongsRecursive3']


class comics_seriesIncludeFromsongsRecursive3(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromsongsRecursive4']


class comics_seriesIncludeFromsongsRecursive4(TypedDict, total=False):
    """Relational arguments for songs"""

    

class comics_seriesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class comics_seriesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class comics_seriesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class comics_seriesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class comics_seriesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    
    

class FindManycomics_seriesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive1'


class FindManycomics_seriesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive2'


class FindManycomics_seriesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive3'


class FindManycomics_seriesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    include: 'comics_seriesIncludeFromcomics_seriesRecursive4'


class FindManycomics_seriesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_seriesOrderByInput', List['comics_seriesOrderByInput']]
    where: 'comics_seriesWhereInput'
    cursor: 'comics_seriesWhereUniqueInput'
    
    

class comics_storiesIncludeFromsongs(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_series: Union[bool, 'comics_seriesArgsFromsongsRecursive1']
    images: Union[bool, 'imagesArgsFromsongsRecursive1']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromsongsRecursive1']


class comics_storiesIncludeFromsongsRecursive1(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_series: Union[bool, 'comics_seriesArgsFromsongsRecursive2']
    images: Union[bool, 'imagesArgsFromsongsRecursive2']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromsongsRecursive2']


class comics_storiesIncludeFromsongsRecursive2(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_series: Union[bool, 'comics_seriesArgsFromsongsRecursive3']
    images: Union[bool, 'imagesArgsFromsongsRecursive3']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromsongsRecursive3']


class comics_storiesIncludeFromsongsRecursive3(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_series: Union[bool, 'comics_seriesArgsFromsongsRecursive4']
    images: Union[bool, 'imagesArgsFromsongsRecursive4']
    comics_issues: Union[bool, 'FindManycomics_issuesArgsFromsongsRecursive4']


class comics_storiesIncludeFromsongsRecursive4(TypedDict, total=False):
    """Relational arguments for songs"""

    

class comics_storiesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class comics_storiesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class comics_storiesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class comics_storiesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class comics_storiesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    
    

class FindManycomics_storiesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive1'


class FindManycomics_storiesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive2'


class FindManycomics_storiesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive3'


class FindManycomics_storiesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    include: 'comics_storiesIncludeFromcomics_storiesRecursive4'


class FindManycomics_storiesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['comics_storiesOrderByInput', List['comics_storiesOrderByInput']]
    where: 'comics_storiesWhereInput'
    cursor: 'comics_storiesWhereUniqueInput'
    
    

class episodesIncludeFromsongs(TypedDict, total=False):
    """Relational arguments for songs"""
    images: Union[bool, 'imagesArgsFromsongsRecursive1']
    songs: Union[bool, 'FindManysongsArgsFromsongsRecursive1']


class episodesIncludeFromsongsRecursive1(TypedDict, total=False):
    """Relational arguments for songs"""
    images: Union[bool, 'imagesArgsFromsongsRecursive2']
    songs: Union[bool, 'FindManysongsArgsFromsongsRecursive2']


class episodesIncludeFromsongsRecursive2(TypedDict, total=False):
    """Relational arguments for songs"""
    images: Union[bool, 'imagesArgsFromsongsRecursive3']
    songs: Union[bool, 'FindManysongsArgsFromsongsRecursive3']


class episodesIncludeFromsongsRecursive3(TypedDict, total=False):
    """Relational arguments for songs"""
    images: Union[bool, 'imagesArgsFromsongsRecursive4']
    songs: Union[bool, 'FindManysongsArgsFromsongsRecursive4']


class episodesIncludeFromsongsRecursive4(TypedDict, total=False):
    """Relational arguments for songs"""

    

class episodesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    include: 'episodesIncludeFromepisodesRecursive1'


class episodesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    include: 'episodesIncludeFromepisodesRecursive2'


class episodesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    include: 'episodesIncludeFromepisodesRecursive3'


class episodesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    include: 'episodesIncludeFromepisodesRecursive4'


class episodesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    
    

class FindManyepisodesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive1'


class FindManyepisodesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive2'


class FindManyepisodesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive3'


class FindManyepisodesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    include: 'episodesIncludeFromepisodesRecursive4'


class FindManyepisodesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['episodesOrderByInput', List['episodesOrderByInput']]
    where: 'episodesWhereInput'
    cursor: 'episodesWhereUniqueInput'
    
    

class imagesIncludeFromsongs(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromsongsRecursive1']
    episodes: Union[bool, 'FindManyepisodesArgsFromsongsRecursive1']


class imagesIncludeFromsongsRecursive1(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromsongsRecursive2']
    episodes: Union[bool, 'FindManyepisodesArgsFromsongsRecursive2']


class imagesIncludeFromsongsRecursive2(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromsongsRecursive3']
    episodes: Union[bool, 'FindManyepisodesArgsFromsongsRecursive3']


class imagesIncludeFromsongsRecursive3(TypedDict, total=False):
    """Relational arguments for songs"""
    comics_stories: Union[bool, 'FindManycomics_storiesArgsFromsongsRecursive4']
    episodes: Union[bool, 'FindManyepisodesArgsFromsongsRecursive4']


class imagesIncludeFromsongsRecursive4(TypedDict, total=False):
    """Relational arguments for songs"""

    

class imagesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    include: 'imagesIncludeFromimagesRecursive1'


class imagesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    include: 'imagesIncludeFromimagesRecursive2'


class imagesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    include: 'imagesIncludeFromimagesRecursive3'


class imagesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    include: 'imagesIncludeFromimagesRecursive4'


class imagesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    
    

class FindManyimagesArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive1'


class FindManyimagesArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive2'


class FindManyimagesArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive3'


class FindManyimagesArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    include: 'imagesIncludeFromimagesRecursive4'


class FindManyimagesArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['imagesOrderByInput', List['imagesOrderByInput']]
    where: 'imagesWhereInput'
    cursor: 'imagesWhereUniqueInput'
    
    

class kindsIncludeFromsongs(TypedDict, total=False):
    """Relational arguments for songs"""


class kindsIncludeFromsongsRecursive1(TypedDict, total=False):
    """Relational arguments for songs"""


class kindsIncludeFromsongsRecursive2(TypedDict, total=False):
    """Relational arguments for songs"""


class kindsIncludeFromsongsRecursive3(TypedDict, total=False):
    """Relational arguments for songs"""


class kindsIncludeFromsongsRecursive4(TypedDict, total=False):
    """Relational arguments for songs"""

    

class kindsArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    include: 'kindsIncludeFromkindsRecursive1'


class kindsArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    include: 'kindsIncludeFromkindsRecursive2'


class kindsArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    include: 'kindsIncludeFromkindsRecursive3'


class kindsArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    include: 'kindsIncludeFromkindsRecursive4'


class kindsArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    
    

class FindManykindsArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive1'


class FindManykindsArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive2'


class FindManykindsArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive3'


class FindManykindsArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    include: 'kindsIncludeFromkindsRecursive4'


class FindManykindsArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['kindsOrderByInput', List['kindsOrderByInput']]
    where: 'kindsWhereInput'
    cursor: 'kindsWhereUniqueInput'
    
    

class songsIncludeFromsongs(TypedDict, total=False):
    """Relational arguments for songs"""
    episodes: Union[bool, 'episodesArgsFromsongsRecursive1']


class songsIncludeFromsongsRecursive1(TypedDict, total=False):
    """Relational arguments for songs"""
    episodes: Union[bool, 'episodesArgsFromsongsRecursive2']


class songsIncludeFromsongsRecursive2(TypedDict, total=False):
    """Relational arguments for songs"""
    episodes: Union[bool, 'episodesArgsFromsongsRecursive3']


class songsIncludeFromsongsRecursive3(TypedDict, total=False):
    """Relational arguments for songs"""
    episodes: Union[bool, 'episodesArgsFromsongsRecursive4']


class songsIncludeFromsongsRecursive4(TypedDict, total=False):
    """Relational arguments for songs"""

    

class songsArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    include: 'songsIncludeFromsongsRecursive1'


class songsArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    include: 'songsIncludeFromsongsRecursive2'


class songsArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    include: 'songsIncludeFromsongsRecursive3'


class songsArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    include: 'songsIncludeFromsongsRecursive4'


class songsArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    
    

class FindManysongsArgsFromsongs(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive1'


class FindManysongsArgsFromsongsRecursive1(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive2'


class FindManysongsArgsFromsongsRecursive2(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive3'


class FindManysongsArgsFromsongsRecursive3(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    include: 'songsIncludeFromsongsRecursive4'


class FindManysongsArgsFromsongsRecursive4(TypedDict, total=False):
    """Arguments for songs"""
    take: int
    skip: int
    order_by: Union['songsOrderByInput', List['songsOrderByInput']]
    where: 'songsWhereInput'
    cursor: 'songsWhereUniqueInput'
    


FindManysongsArgs = FindManysongsArgsFromsongs
FindFirstsongsArgs = FindManysongsArgsFromsongs


    

class songsWhereInput(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    EpisodeID: Union[int, 'types.IntFilter']
    VideoUrl: Union[str, 'types.StringFilter']
    Length: Union[str, 'types.StringFilter']
    MusicBy: Union[str, 'types.StringFilter']
    LyricsBy: Union[str, 'types.StringFilter']
    KeySignatures: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    episodes: 'episodesRelationFilter'

    # should be noted that AND and NOT should be Union['songsWhereInputRecursive1', List['songsWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['songsWhereInputRecursive1']
    OR: List['songsWhereInputRecursive1']
    NOT: List['songsWhereInputRecursive1']


class songsWhereInputRecursive1(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    EpisodeID: Union[int, 'types.IntFilter']
    VideoUrl: Union[str, 'types.StringFilter']
    Length: Union[str, 'types.StringFilter']
    MusicBy: Union[str, 'types.StringFilter']
    LyricsBy: Union[str, 'types.StringFilter']
    KeySignatures: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    episodes: 'episodesRelationFilter'

    # should be noted that AND and NOT should be Union['songsWhereInputRecursive2', List['songsWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['songsWhereInputRecursive2']
    OR: List['songsWhereInputRecursive2']
    NOT: List['songsWhereInputRecursive2']


class songsWhereInputRecursive2(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    EpisodeID: Union[int, 'types.IntFilter']
    VideoUrl: Union[str, 'types.StringFilter']
    Length: Union[str, 'types.StringFilter']
    MusicBy: Union[str, 'types.StringFilter']
    LyricsBy: Union[str, 'types.StringFilter']
    KeySignatures: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    episodes: 'episodesRelationFilter'

    # should be noted that AND and NOT should be Union['songsWhereInputRecursive3', List['songsWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['songsWhereInputRecursive3']
    OR: List['songsWhereInputRecursive3']
    NOT: List['songsWhereInputRecursive3']


class songsWhereInputRecursive3(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    EpisodeID: Union[int, 'types.IntFilter']
    VideoUrl: Union[str, 'types.StringFilter']
    Length: Union[str, 'types.StringFilter']
    MusicBy: Union[str, 'types.StringFilter']
    LyricsBy: Union[str, 'types.StringFilter']
    KeySignatures: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    episodes: 'episodesRelationFilter'

    # should be noted that AND and NOT should be Union['songsWhereInputRecursive4', List['songsWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['songsWhereInputRecursive4']
    OR: List['songsWhereInputRecursive4']
    NOT: List['songsWhereInputRecursive4']


class songsWhereInputRecursive4(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntFilter']
    Name: Union[str, 'types.StringFilter']
    EpisodeID: Union[int, 'types.IntFilter']
    VideoUrl: Union[str, 'types.StringFilter']
    Length: Union[str, 'types.StringFilter']
    MusicBy: Union[str, 'types.StringFilter']
    LyricsBy: Union[str, 'types.StringFilter']
    KeySignatures: Union[str, 'types.StringFilter']
    Url: Union[str, 'types.StringFilter']
    episodes: 'episodesRelationFilter'



# aggregate songs types


    

class songsScalarWhereWithAggregatesInput(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    VideoUrl: Union[str, 'types.StringWithAggregatesFilter']
    Length: Union[str, 'types.StringWithAggregatesFilter']
    MusicBy: Union[str, 'types.StringWithAggregatesFilter']
    LyricsBy: Union[str, 'types.StringWithAggregatesFilter']
    KeySignatures: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['songsScalarWhereWithAggregatesInputRecursive1']
    OR: List['songsScalarWhereWithAggregatesInputRecursive1']
    NOT: List['songsScalarWhereWithAggregatesInputRecursive1']


class songsScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    VideoUrl: Union[str, 'types.StringWithAggregatesFilter']
    Length: Union[str, 'types.StringWithAggregatesFilter']
    MusicBy: Union[str, 'types.StringWithAggregatesFilter']
    LyricsBy: Union[str, 'types.StringWithAggregatesFilter']
    KeySignatures: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['songsScalarWhereWithAggregatesInputRecursive2']
    OR: List['songsScalarWhereWithAggregatesInputRecursive2']
    NOT: List['songsScalarWhereWithAggregatesInputRecursive2']


class songsScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    VideoUrl: Union[str, 'types.StringWithAggregatesFilter']
    Length: Union[str, 'types.StringWithAggregatesFilter']
    MusicBy: Union[str, 'types.StringWithAggregatesFilter']
    LyricsBy: Union[str, 'types.StringWithAggregatesFilter']
    KeySignatures: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['songsScalarWhereWithAggregatesInputRecursive3']
    OR: List['songsScalarWhereWithAggregatesInputRecursive3']
    NOT: List['songsScalarWhereWithAggregatesInputRecursive3']


class songsScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    VideoUrl: Union[str, 'types.StringWithAggregatesFilter']
    Length: Union[str, 'types.StringWithAggregatesFilter']
    MusicBy: Union[str, 'types.StringWithAggregatesFilter']
    LyricsBy: Union[str, 'types.StringWithAggregatesFilter']
    KeySignatures: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']

    AND: List['songsScalarWhereWithAggregatesInputRecursive4']
    OR: List['songsScalarWhereWithAggregatesInputRecursive4']
    NOT: List['songsScalarWhereWithAggregatesInputRecursive4']


class songsScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """songs arguments for searching"""
    SongID: Union[int, 'types.IntWithAggregatesFilter']
    Name: Union[str, 'types.StringWithAggregatesFilter']
    EpisodeID: Union[int, 'types.IntWithAggregatesFilter']
    VideoUrl: Union[str, 'types.StringWithAggregatesFilter']
    Length: Union[str, 'types.StringWithAggregatesFilter']
    MusicBy: Union[str, 'types.StringWithAggregatesFilter']
    LyricsBy: Union[str, 'types.StringWithAggregatesFilter']
    KeySignatures: Union[str, 'types.StringWithAggregatesFilter']
    Url: Union[str, 'types.StringWithAggregatesFilter']



class songsGroupByOutput(TypedDict, total=False):
    SongID: int
    Name: str
    EpisodeID: int
    VideoUrl: str
    Length: str
    MusicBy: str
    LyricsBy: str
    KeySignatures: str
    Url: str
    _sum: 'songsSumAggregateOutput'
    _avg: 'songsAvgAggregateOutput'
    _min: 'songsMinAggregateOutput'
    _max: 'songsMaxAggregateOutput'
    _count: 'songsCountAggregateOutput'


class songsAvgAggregateOutput(TypedDict, total=False):
    """songs output for aggregating averages"""
    SongID: float
    EpisodeID: float


class songsSumAggregateOutput(TypedDict, total=False):
    """songs output for aggregating sums"""
    SongID: int
    EpisodeID: int


class songsScalarAggregateOutput(TypedDict, total=False):
    """songs output including scalar fields"""
    SongID: int
    Name: str
    EpisodeID: int
    VideoUrl: str
    Length: str
    MusicBy: str
    LyricsBy: str
    KeySignatures: str
    Url: str


songsMinAggregateOutput = songsScalarAggregateOutput
songsMaxAggregateOutput = songsScalarAggregateOutput


class songsMaxAggregateInput(TypedDict, total=False):
    """songs input for aggregating by max"""
    SongID: bool
    Name: bool
    EpisodeID: bool
    VideoUrl: bool
    Length: bool
    MusicBy: bool
    LyricsBy: bool
    KeySignatures: bool
    Url: bool


class songsMinAggregateInput(TypedDict, total=False):
    """songs input for aggregating by min"""
    SongID: bool
    Name: bool
    EpisodeID: bool
    VideoUrl: bool
    Length: bool
    MusicBy: bool
    LyricsBy: bool
    KeySignatures: bool
    Url: bool


class songsNumberAggregateInput(TypedDict, total=False):
    """songs input for aggregating numbers"""
    SongID: bool
    EpisodeID: bool


songsAvgAggregateInput = songsNumberAggregateInput
songsSumAggregateInput = songsNumberAggregateInput


songsCountAggregateInput = TypedDict(
    'songsCountAggregateInput',
    {
        'SongID': bool,
        'Name': bool,
        'EpisodeID': bool,
        'VideoUrl': bool,
        'Length': bool,
        'MusicBy': bool,
        'LyricsBy': bool,
        'KeySignatures': bool,
        'Url': bool,
        '_all': bool,
    },
    total=False,
)

songsCountAggregateOutput = TypedDict(
    'songsCountAggregateOutput',
    {
        'SongID': int,
        'Name': int,
        'EpisodeID': int,
        'VideoUrl': int,
        'Length': int,
        'MusicBy': int,
        'LyricsBy': int,
        'KeySignatures': int,
        'Url': int,
        '_all': int,
    },
    total=False,
)


songsKeys = Literal[
    'SongID',
    'Name',
    'EpisodeID',
    'VideoUrl',
    'Length',
    'MusicBy',
    'LyricsBy',
    'KeySignatures',
    'Url',
    'episodes',
]
songsScalarFieldKeys = Literal[
    'SongID',
    'Name',
    'EpisodeID',
    'VideoUrl',
    'Length',
    'MusicBy',
    'LyricsBy',
    'KeySignatures',
    'Url',
]
songsScalarFieldKeysT = TypeVar('songsScalarFieldKeysT', bound=songsScalarFieldKeys)

songsRelationalFieldKeys = Literal[
        'episodes',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields