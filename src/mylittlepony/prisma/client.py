# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pylint: disable=all
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import sys
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Callable,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal

# -- template client.py.jinja --
from types import TracebackType

from . import types, models, errors, actions
from .types import DatasourceOverride, HttpConfig
from ._types import BaseModelT
from .engine import AbstractEngine, QueryEngine
from .builder import QueryBuilder
from .generator.models import EngineType


__all__ = (
    'ENGINE_TYPE',
    'Client',
    'load_env',
    'register',
    'get_client',
)

SCHEMA = '''
generator db {
  provider  = "prisma-client-py"
  output    = "prisma"
  interface = "asyncio"
}

datasource db {
  provider = "sqlite"
  url      = "file:db.sqlite"
}

model characters {
  CharacterID       Int                 @id @default(autoincrement())
  Name              String              @unique(map: "sqlite_autoindex_characters_1")
  Alias             String?
  Sex               String?
  Residences        String?
  Occupations       String?
  Url               String
  characters_images characters_images[]
  characters_kinds  characters_kinds[]

  @@index([Alias], map: "idx_characters_Alias")
  @@index([Residences], map: "idx_characters_Residences")
  @@index([Occupations], map: "idx_characters_Occupations")
}

model characters_images {
  uid         Int        @id @default(autoincrement())
  CharacterID Int
  ImageID     Int
  characters  characters @relation(fields: [CharacterID], references: [CharacterID], onDelete: NoAction)
  images      images     @relation(fields: [ImageID], references: [ImageID], onDelete: Cascade)

  @@index([ImageID], map: "idx_characters_images_ImageID")
  @@index([CharacterID], map: "idx_characters_images_CharacterID")
}

model characters_kinds {
  uid         Int        @id @default(autoincrement())
  CharacterID Int
  KindID      Int
  Comment     String?
  characters  characters @relation(fields: [CharacterID], references: [CharacterID], onDelete: NoAction)
  kinds       kinds      @relation(fields: [KindID], references: [KindID], onDelete: NoAction)

  @@index([CharacterID], map: "idx_characters_kinds_CharacterID")
  @@index([KindID], map: "idx_characters_kinds_KindID")
}

model comics_issues {
  ComicsIssueID  Int            @id @default(autoincrement())
  IssueNo        Int?
  ComicsStoryID  Int
  PublishDate    DateTime
  Annotation     String?
  comics_stories comics_stories @relation(fields: [ComicsStoryID], references: [ComicsStoryID], onDelete: NoAction, onUpdate: NoAction)

  @@index([IssueNo], map: "idx_comics_issues_IssueNo")
  @@index([ComicsStoryID], map: "idx_comics_issues_ComicsStoryID")
}

model comics_series {
  ComicsSeriesID Int              @id @default(autoincrement())
  Name           String           @unique(map: "sqlite_autoindex_comics_series_1")
  Url            String
  comics_stories comics_stories[]
}

model comics_stories {
  ComicsStoryID  Int             @id @default(autoincrement())
  Name           String          @unique(map: "sqlite_autoindex_comics_stories_1")
  ComicsSeriesID Int
  ImageID        Int?
  Url            String?         @unique(map: "sqlite_autoindex_comics_stories_2")
  Writer         String?
  Artist         String?
  Colorist       String?
  Letterer       String?
  Editor         String?
  comics_series  comics_series   @relation(fields: [ComicsSeriesID], references: [ComicsSeriesID], onDelete: NoAction)
  images         images?         @relation(fields: [ImageID], references: [ImageID], onDelete: Cascade)
  comics_issues  comics_issues[]

  @@index([Editor], map: "idx_comics_stories_Editor")
  @@index([Letterer], map: "idx_comics_stories_Letterer")
  @@index([Colorist], map: "idx_comics_stories_Colorist")
  @@index([Artist], map: "idx_comics_stories_Artist")
  @@index([Writer], map: "idx_comics_stories_Writer")
  @@index([ComicsSeriesID], map: "idx_comics_stories_ComicsSeriesID")
  @@index([ImageID], map: "idx_comics_stories_ImageID")
}

model episodes {
  EpisodeID      Int      @id @default(autoincrement())
  Name           String   @unique(map: "sqlite_autoindex_episodes_1")
  ImageID        Int
  Season         Int?
  Episode        Int?
  OverallEpisode Int?     @unique(map: "sqlite_autoindex_episodes_2")
  Airdate        DateTime
  StoryBy        String?
  WrittenBy      String?
  Storyboard     String?
  Url            String
  images         images   @relation(fields: [ImageID], references: [ImageID], onDelete: NoAction)
  songs          songs[]

  @@index([Storyboard], map: "idx_episodes_Storyboard")
  @@index([WrittenBy], map: "idx_episodes_WrittenBy")
  @@index([StoryBy], map: "idx_episodes_StoryBy")
  @@index([ImageID], map: "idx_episodes_ImageID")
  @@index([Episode], map: "idx_episodes_Episode")
  @@index([Season], map: "idx_episodes_Season")
}

model images {
  ImageID           Int                 @id @default(autoincrement())
  Name              String              @unique(map: "sqlite_autoindex_images_1")
  Url               String
  Comment           String?
  characters_images characters_images[]
  comics_stories    comics_stories[]
  episodes          episodes[]
}

model kinds {
  KindID           Int                @id @default(autoincrement())
  Name             String
  Url              String?            @unique(map: "sqlite_autoindex_kinds_1")
  characters_kinds characters_kinds[]
}

model songs {
  SongID        Int      @id @default(autoincrement())
  Name          String   @unique(map: "sqlite_autoindex_songs_1")
  EpisodeID     Int
  VideoUrl      String
  Length        String
  MusicBy       String?
  LyricsBy      String?
  KeySignatures String?
  Url           String
  episodes      episodes @relation(fields: [EpisodeID], references: [EpisodeID], onDelete: NoAction)

  @@index([EpisodeID], map: "idx_songs_EpisodeID")
  @@index([MusicBy], map: "idx_songs_MusicBy")
  @@index([LyricsBy], map: "idx_songs_LyricsBy")
  @@index([KeySignatures], map: "idx_songs_KeySignatures")
}

'''

ENGINE_TYPE: EngineType = EngineType.binary

RegisteredClient = Union['Client', Callable[[], 'Client']]
_registered_client: Optional[RegisteredClient] = None


class UseClientDefault:
    """For certain parameters such as `timeout=...` we can make our intent more clear
    by typing the parameter with this class rather than using None, for example:

    ```py
    def connect(timeout: Union[int, UseClientDefault] = UseClientDefault()) -> None: ...
    ```

    relays the intention more clearly than:

    ```py
    def connect(timeout: Optional[int] = None) -> None: ...
    ```

    This solution also allows us to indicate an "unset" state that is uniquely distinct
    from `None` which may be useful in the future.
    """


_USE_CLIENT_DEFAULT = UseClientDefault()


def load_env(*, override: bool = True, **kwargs: Any) -> None:
    """Load environemntal variables from dotenv files

    Loads from the following files relative to the current
    working directory:

    - .env
    - prisma/.env
    """
    from dotenv import load_dotenv

    load_dotenv('.env', override=override, **kwargs)
    load_dotenv('prisma/.env', override=override, **kwargs)


def register(client: RegisteredClient) -> None:
    """Register a client instance to be retrieved by `get_client()`

    This function _must_ only be called once, preferrably as soon as possible
    to avoid any potentially confusing errors with threads or processes.
    """
    global _registered_client

    if _registered_client is not None:
        raise errors.ClientAlreadyRegisteredError()

    if not isinstance(client, Client) and not callable(client):
        raise TypeError(
            f'Expected either a {Client} instance or a function that returns a {Client} but got {client} instead.'
        )

    _registered_client = client


def get_client() -> 'Client':
    """Get the registered client instance

    Raises errors.ClientNotRegisteredError() if no client instance has been registered.
    """
    registered = _registered_client
    if registered is None:
        raise errors.ClientNotRegisteredError() from None

    if isinstance(registered, Client):
        return registered

    client = registered()
    if not isinstance(client, Client):  # pyright: reportUnnecessaryIsInstance=false
        raise TypeError(
            f'Registered function returned {client} instead of a {Client} instance.'
        )

    return client


class Client:
    characters: 'actions.charactersActions'
    characters_images: 'actions.characters_imagesActions'
    characters_kinds: 'actions.characters_kindsActions'
    comics_issues: 'actions.comics_issuesActions'
    comics_series: 'actions.comics_seriesActions'
    comics_stories: 'actions.comics_storiesActions'
    episodes: 'actions.episodesActions'
    images: 'actions.imagesActions'
    kinds: 'actions.kindsActions'
    songs: 'actions.songsActions'

    def __init__(
        self,
        *,
        use_dotenv: bool = True,
        log_queries: bool = False,
        auto_register: bool = False,
        datasource: Optional[DatasourceOverride] = None,
        connect_timeout: int = 10,
        http: Optional[HttpConfig] = None,
    ) -> None:
        self.characters = actions.charactersActions(self, models.characters)
        self.characters_images = actions.characters_imagesActions(self, models.characters_images)
        self.characters_kinds = actions.characters_kindsActions(self, models.characters_kinds)
        self.comics_issues = actions.comics_issuesActions(self, models.comics_issues)
        self.comics_series = actions.comics_seriesActions(self, models.comics_series)
        self.comics_stories = actions.comics_storiesActions(self, models.comics_stories)
        self.episodes = actions.episodesActions(self, models.episodes)
        self.images = actions.imagesActions(self, models.images)
        self.kinds = actions.kindsActions(self, models.kinds)
        self.songs = actions.songsActions(self, models.songs)
        self.__engine: Optional[AbstractEngine] = None
        self._active_provider = 'sqlite'
        self._log_queries = log_queries
        self._datasource = datasource
        self._connect_timeout = connect_timeout
        self._http_config: HttpConfig = http or {}

        if use_dotenv:
            load_env()

        if auto_register:
            register(self)

    def __del__(self) -> None:
        if self.__engine is not None:
            self.__engine.stop()
            self.__engine = None

    async def __aenter__(self) -> 'Client':
        await self.connect()
        return self

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> None:
        if self.is_connected():
            await self.disconnect()

    def is_connected(self) -> bool:
        """Returns True if the client is connected to the query engine, False otherwise."""
        return self.__engine is not None

    async def connect(
        self,
        timeout: Union[int, UseClientDefault] = _USE_CLIENT_DEFAULT,
    ) -> None:
        """Connect to the Prisma query engine.

        It is required to call this before accessing data.
        """
        if isinstance(timeout, UseClientDefault):
            timeout = self._connect_timeout

        if self.__engine is None:
            self.__engine = self._create_engine(dml=SCHEMA)

        datasources: Optional[List[types.DatasourceOverride]] = None
        if self._datasource is not None:
            ds = self._datasource.copy()
            ds.setdefault('name', 'db')
            datasources = [ds]

        await self.__engine.connect(
            timeout=timeout,
            datasources=datasources,
        )

    async def disconnect(self) -> None:
        """Disconnect the Prisma query engine."""
        if self.__engine is not None:
            self.__engine.close()
            await self.__engine.aclose()
            self.__engine = None

    async def execute_raw(self, query: str, *args: Any) -> int:
        resp = await self._execute(
            operation='mutation',
            method='executeRaw',
            arguments={
                'query': query,
                'parameters': args,
            }
        )
        return int(resp['data']['result'])

    @overload
    async def query_first(self, query: str, *args: Any) -> Any:
        ...

    @overload
    async def query_first(self, query: str, *args: Any, model: Type[BaseModelT]) -> Optional[BaseModelT]:
        ...

    async def query_first(
        self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
    ) -> Union[Optional[BaseModelT], Any]:
        if model is not None:
            results = await self.query_raw(query, *args, model=model)
        else:
            results = await self.query_raw(query, *args)

        if not results:
            return None

        return results[0]

    @overload
    async def query_raw(self, query: str, *args: Any) -> Any:
        ...

    @overload
    async def query_raw(self, query: str, *args: Any, model: Type[BaseModelT]) -> List[BaseModelT]:
        ...

    async def query_raw(
        self, query: str, *args: Any, model: Optional[Type[BaseModelT]] = None
    ) -> Union[List[BaseModelT], Any]:
        resp = await self._execute(
            operation='mutation',
            method='queryRaw',
            arguments={
                'query': query,
                'parameters': args,
            }
        )
        result = resp['data']['result']
        if model is not None:
            return [model.parse_obj(r) for r in result]
        return result

    def batch_(self) -> 'Batch':
        """Returns a context manager for grouping write queries into a single transaction."""
        return Batch(client=self)

    # TODO: don't return Any
    async def _execute(
        self,
        method: str,
        operation: str,
        arguments: Dict[str, Any],
        model: Optional[str] = None,
        root_selection: Optional[List[str]] = None
    ) -> Any:
        builder = QueryBuilder(
            operation=operation,
            method=method,
            model=model,
            arguments=arguments,
            root_selection=root_selection,
        )
        return await self._engine.query(builder.build())

    def _create_engine(self, dml: str = SCHEMA) -> AbstractEngine:
        if ENGINE_TYPE == EngineType.binary:
            return QueryEngine(dml=dml, log_queries=self._log_queries, **self._http_config)

        raise NotImplementedError(f'Unsupported engine type: {ENGINE_TYPE}')

    @property
    def _engine_class(self) -> Type[AbstractEngine]:
        if ENGINE_TYPE == EngineType.binary:
            return QueryEngine
        else:  # pragma: no cover
            raise RuntimeError(f'Unhandled engine type: {ENGINE_TYPE}')

    @property
    def _engine(self) -> AbstractEngine:
        engine = self.__engine
        if engine is None:
            raise errors.ClientNotConnectedError()
        return engine


# TODO: this should return the results as well
# TODO: don't require copy-pasting arguments between actions and batch actions
class Batch:
    characters: 'charactersBatchActions'
    characters_images: 'characters_imagesBatchActions'
    characters_kinds: 'characters_kindsBatchActions'
    comics_issues: 'comics_issuesBatchActions'
    comics_series: 'comics_seriesBatchActions'
    comics_stories: 'comics_storiesBatchActions'
    episodes: 'episodesBatchActions'
    images: 'imagesBatchActions'
    kinds: 'kindsBatchActions'
    songs: 'songsBatchActions'

    def __init__(self, client: Client) -> None:
        self.__client = client
        self.__queries: List[str] = []
        self._active_provider = client._active_provider
        self.characters = charactersBatchActions(self)
        self.characters_images = characters_imagesBatchActions(self)
        self.characters_kinds = characters_kindsBatchActions(self)
        self.comics_issues = comics_issuesBatchActions(self)
        self.comics_series = comics_seriesBatchActions(self)
        self.comics_stories = comics_storiesBatchActions(self)
        self.episodes = episodesBatchActions(self)
        self.images = imagesBatchActions(self)
        self.kinds = kindsBatchActions(self)
        self.songs = songsBatchActions(self)

    def _add(self, **kwargs: Any) -> None:
        builder = QueryBuilder(**kwargs)
        self.__queries.append(builder.build_query())

    async def commit(self) -> None:
        """Execute the queries"""
        # TODO: normalise this, we should still call client._execute
        from .builder import dumps

        queries = self.__queries
        self.__queries = []

        payload = {
            'batch': [
                {
                    'query': query,
                    'variables': {},
                }
                for query in queries
            ],
            'transaction': True,
        }
        await self.__client._engine.query(dumps(payload))

    async def __aenter__(self) -> 'Batch':
        return self

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> None:
        if exc is None:
            await self.commit()


# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class charactersBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.charactersCreateInput,
        include: Optional[types.charactersInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='characters',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.charactersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='characters',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.charactersWhereUniqueInput,
        include: Optional[types.charactersInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='characters',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.charactersUpdateInput,
        where: types.charactersWhereUniqueInput,
        include: Optional[types.charactersInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='characters',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.charactersWhereUniqueInput,
        data: types.charactersUpsertInput,
        include: Optional[types.charactersInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='characters',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.charactersUpdateManyMutationInput,
        where: types.charactersWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='characters',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.charactersWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='characters',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class characters_imagesBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.characters_imagesCreateInput,
        include: Optional[types.characters_imagesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='characters_images',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.characters_imagesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='characters_images',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.characters_imagesWhereUniqueInput,
        include: Optional[types.characters_imagesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='characters_images',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.characters_imagesUpdateInput,
        where: types.characters_imagesWhereUniqueInput,
        include: Optional[types.characters_imagesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='characters_images',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.characters_imagesWhereUniqueInput,
        data: types.characters_imagesUpsertInput,
        include: Optional[types.characters_imagesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='characters_images',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.characters_imagesUpdateManyMutationInput,
        where: types.characters_imagesWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='characters_images',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.characters_imagesWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='characters_images',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class characters_kindsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.characters_kindsCreateInput,
        include: Optional[types.characters_kindsInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='characters_kinds',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.characters_kindsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='characters_kinds',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.characters_kindsWhereUniqueInput,
        include: Optional[types.characters_kindsInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='characters_kinds',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.characters_kindsUpdateInput,
        where: types.characters_kindsWhereUniqueInput,
        include: Optional[types.characters_kindsInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='characters_kinds',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.characters_kindsWhereUniqueInput,
        data: types.characters_kindsUpsertInput,
        include: Optional[types.characters_kindsInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='characters_kinds',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.characters_kindsUpdateManyMutationInput,
        where: types.characters_kindsWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='characters_kinds',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.characters_kindsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='characters_kinds',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class comics_issuesBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.comics_issuesCreateInput,
        include: Optional[types.comics_issuesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='comics_issues',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.comics_issuesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='comics_issues',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.comics_issuesWhereUniqueInput,
        include: Optional[types.comics_issuesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='comics_issues',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.comics_issuesUpdateInput,
        where: types.comics_issuesWhereUniqueInput,
        include: Optional[types.comics_issuesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='comics_issues',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.comics_issuesWhereUniqueInput,
        data: types.comics_issuesUpsertInput,
        include: Optional[types.comics_issuesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='comics_issues',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.comics_issuesUpdateManyMutationInput,
        where: types.comics_issuesWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='comics_issues',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.comics_issuesWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='comics_issues',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class comics_seriesBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.comics_seriesCreateInput,
        include: Optional[types.comics_seriesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='comics_series',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.comics_seriesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='comics_series',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.comics_seriesWhereUniqueInput,
        include: Optional[types.comics_seriesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='comics_series',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.comics_seriesUpdateInput,
        where: types.comics_seriesWhereUniqueInput,
        include: Optional[types.comics_seriesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='comics_series',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.comics_seriesWhereUniqueInput,
        data: types.comics_seriesUpsertInput,
        include: Optional[types.comics_seriesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='comics_series',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.comics_seriesUpdateManyMutationInput,
        where: types.comics_seriesWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='comics_series',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.comics_seriesWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='comics_series',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class comics_storiesBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.comics_storiesCreateInput,
        include: Optional[types.comics_storiesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='comics_stories',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.comics_storiesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='comics_stories',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.comics_storiesWhereUniqueInput,
        include: Optional[types.comics_storiesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='comics_stories',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.comics_storiesUpdateInput,
        where: types.comics_storiesWhereUniqueInput,
        include: Optional[types.comics_storiesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='comics_stories',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.comics_storiesWhereUniqueInput,
        data: types.comics_storiesUpsertInput,
        include: Optional[types.comics_storiesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='comics_stories',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.comics_storiesUpdateManyMutationInput,
        where: types.comics_storiesWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='comics_stories',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.comics_storiesWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='comics_stories',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class episodesBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.episodesCreateInput,
        include: Optional[types.episodesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='episodes',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.episodesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='episodes',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.episodesWhereUniqueInput,
        include: Optional[types.episodesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='episodes',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.episodesUpdateInput,
        where: types.episodesWhereUniqueInput,
        include: Optional[types.episodesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='episodes',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.episodesWhereUniqueInput,
        data: types.episodesUpsertInput,
        include: Optional[types.episodesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='episodes',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.episodesUpdateManyMutationInput,
        where: types.episodesWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='episodes',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.episodesWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='episodes',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class imagesBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.imagesCreateInput,
        include: Optional[types.imagesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='images',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.imagesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='images',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.imagesWhereUniqueInput,
        include: Optional[types.imagesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='images',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.imagesUpdateInput,
        where: types.imagesWhereUniqueInput,
        include: Optional[types.imagesInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='images',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.imagesWhereUniqueInput,
        data: types.imagesUpsertInput,
        include: Optional[types.imagesInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='images',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.imagesUpdateManyMutationInput,
        where: types.imagesWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='images',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.imagesWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='images',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class kindsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.kindsCreateInput,
        include: Optional[types.kindsInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='kinds',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.kindsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='kinds',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.kindsWhereUniqueInput,
        include: Optional[types.kindsInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='kinds',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.kindsUpdateInput,
        where: types.kindsWhereUniqueInput,
        include: Optional[types.kindsInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='kinds',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.kindsWhereUniqueInput,
        data: types.kindsUpsertInput,
        include: Optional[types.kindsInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='kinds',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.kindsUpdateManyMutationInput,
        where: types.kindsWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='kinds',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.kindsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='kinds',
            arguments={'where': where},
            root_selection=['count'],
        )



# NOTE: some arguments are meaningless in this context but are included
# for completeness sake
class songsBatchActions:
    def __init__(self, batcher: Batch) -> None:
        self._batcher = batcher

    def create(
        self,
        data: types.songsCreateInput,
        include: Optional[types.songsInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='createOne',
            model='songs',
            arguments={
                'data': data,
                'include': include,
            },
        )

    def create_many(
        self,
        data: List[types.songsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> None:
        if self._batcher._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        self._batcher._add(
            operation='mutation',
            method='createMany',
            model='songs',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )

    def delete(
        self,
        where: types.songsWhereUniqueInput,
        include: Optional[types.songsInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteOne',
            model='songs',
            arguments={
                'where': where,
                'include': include,
            },
        )

    def update(
        self,
        data: types.songsUpdateInput,
        where: types.songsWhereUniqueInput,
        include: Optional[types.songsInclude] = None
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateOne',
            model='songs',
            arguments={
                'data': data,
                'where': where,
                'include': include,
            },
        )

    def upsert(
        self,
        where: types.songsWhereUniqueInput,
        data: types.songsUpsertInput,
        include: Optional[types.songsInclude] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='upsertOne',
            model='songs',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )

    def update_many(
        self,
        data: types.songsUpdateManyMutationInput,
        where: types.songsWhereInput,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='updateMany',
            model='songs',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )

    def delete_many(
        self,
        where: Optional[types.songsWhereInput] = None,
    ) -> None:
        self._batcher._add(
            operation='mutation',
            method='deleteMany',
            model='songs',
            arguments={'where': where},
            root_selection=['count'],
        )


