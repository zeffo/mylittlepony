# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pylint: disable=all
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import sys
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Callable,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal

# -- template actions.py.jinja --
import warnings

from . import types, errors
from ._types import BaseModelT


if TYPE_CHECKING:
    from .client import Client


class charactersActions:
    def __init__(self, client: 'Client', model: Type['models.characters']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.characters']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.characters]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await characters.prisma().query_raw(
            'SELECT * FROM characters WHERE CharacterID = ?',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.characters']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.characters
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await characters.prisma().query_first(
            'SELECT * FROM characters WHERE Name = ?',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.charactersCreateInput,
        include: Optional[types.charactersInclude] = None
    ) -> 'models.characters':
        """Create a new characters record.

        Parameters
        ----------
        data
            characters record data
        include
            Specifies which relations should be loaded on the returned characters model

        Returns
        -------
        prisma.models.characters
            The created characters record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a characters record from just the required fields
        characters = await characters.prisma().create(
            data={
                # data to create a characters record
                'Name': 'ggciceaie',
                'Url': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='characters',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.charactersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple characters records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of characters record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await characters.prisma().create_many(
            data=[
                {
                    # data to create a characters record
                    'Name': 'cadfabfehe',
                    'Url': 'dgiiaaijj',
                },
                {
                    # data to create a characters record
                    'Name': 'bfaiacjjfc',
                    'Url': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='characters',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.charactersWhereUniqueInput,
        include: Optional[types.charactersInclude] = None
    ) -> Optional['models.characters']:
        """Delete a single characters record.

        Parameters
        ----------
        where
            characters filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned characters model

        Returns
        -------
        prisma.models.characters
            The deleted characters record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters = await characters.prisma().delete(
            where={
                'CharacterID': 1062517886,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='characters',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.charactersWhereUniqueInput,
        include: Optional[types.charactersInclude] = None
    ) -> Optional['models.characters']:
        """Find a unique characters record.

        Parameters
        ----------
        where
            characters filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned characters model

        Returns
        -------
        prisma.models.characters
            The found characters record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters = await characters.prisma().find_unique(
            where={
                'CharacterID': 267834847,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='characters',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.charactersWhereInput] = None,
        cursor: Optional[types.charactersWhereUniqueInput] = None,
        include: Optional[types.charactersInclude] = None,
        order: Optional[Union[types.charactersOrderByInput, List[types.charactersOrderByInput]]] = None,
    ) -> List['models.characters']:
        """Find multiple characters records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of characters records returned
        skip
            Ignore the first N results
        where
            characters filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned characters model
        order
            Order the returned characters records by any field

        Returns
        -------
        List[prisma.models.characters]
            The list of all characters records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 characters records
        characters = await characters.prisma().find_many(take=10)

        # find the first 5 characters records ordered by the Alias field
        characters = await characters.prisma().find_many(
            take=5,
            order={
                'Alias': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='characters',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.charactersWhereInput] = None,
        cursor: Optional[types.charactersWhereUniqueInput] = None,
        include: Optional[types.charactersInclude] = None,
        order: Optional[Union[types.charactersOrderByInput, List[types.charactersOrderByInput]]] = None,
    ) -> Optional['models.characters']:
        """Find a single characters record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            characters filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned characters model
        order
            Order the returned characters records by any field

        Returns
        -------
        prisma.models.characters
            The first characters record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second characters record ordered by the Sex field
        characters = await characters.prisma().find_first(
            skip=1,
            order={
                'Sex': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='characters',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.charactersUpdateInput,
        where: types.charactersWhereUniqueInput,
        include: Optional[types.charactersInclude] = None
    ) -> Optional['models.characters']:
        """Update a single characters record.

        Parameters
        ----------
        data
            characters record data specifying what to update
        where
            characters filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned characters model

        Returns
        -------
        prisma.models.characters
            The updated characters record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        characters = await characters.prisma().update(
            where={
                'CharacterID': 180171308,
            },
            data={
                # data to update the characters record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='characters',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.charactersWhereUniqueInput,
        data: types.charactersUpsertInput,
        include: Optional[types.charactersInclude] = None,
    ) -> 'models.characters':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            characters filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned characters model

        Returns
        -------
        prisma.models.characters
            The created or updated characters record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters = await characters.prisma().upsert(
            where={
                'CharacterID': 836760821,
            },
            data={
                'create': {
                    'CharacterID': 836760821,
                    'Name': 'bfaiacjjfc',
                    'Url': 'eigcfgbif',
                },
                'update': {
                    'Name': 'bfaiacjjfc',
                    'Url': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='characters',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.charactersUpdateManyMutationInput,
        where: types.charactersWhereInput,
    ) -> int:
        """Update multiple characters records

        Parameters
        ----------
        data
            characters data to update the selected characters records to
        where
            Filter to select the characters records to update

        Returns
        -------
        int
            The total number of characters records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all characters records
        total = await characters.prisma().update_many(
            data={
                'Residences': 'fjfddhigg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='characters',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.charactersWhereInput] = None,
        cursor: Optional[types.charactersWhereUniqueInput] = None,
    ) -> int:
        """Count the number of characters records present in the database

        Parameters
        ----------
        select
            Select the characters fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            characters filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.charactersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await characters.prisma().count()

        # results: prisma.types.charactersCountAggregateOutput
        results = await characters.prisma().count(
            select={
                '_all': True,
                'Occupations': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.charactersCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.charactersWhereInput] = None,
        cursor: Optional[types.charactersWhereUniqueInput] = None,
    ) -> types.charactersCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.charactersCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.charactersWhereInput] = None,
        cursor: Optional[types.charactersWhereUniqueInput] = None,
    ) -> Union[int, types.charactersCountAggregateOutput]:
        """Count the number of characters records present in the database

        Parameters
        ----------
        select
            Select the characters fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            characters filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.charactersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await characters.prisma().count()

        # results: prisma.types.charactersCountAggregateOutput
        results = await characters.prisma().count(
            select={
                '_all': True,
                'Url': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='characters',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.charactersCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.charactersWhereInput] = None
    ) -> int:
        """Delete multiple characters records.

        Parameters
        ----------
        where
            Optional characters filter to find the records to be deleted

        Returns
        -------
        int
            The total number of characters records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all characters records
        total = await characters.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='characters',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.charactersScalarFieldKeys'],
        *,
        where: Optional['types.charactersWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.charactersAvgAggregateInput'] = None,
        sum: Optional['types.charactersSumAggregateInput'] = None,
        min: Optional['types.charactersMinAggregateInput'] = None,
        max: Optional['types.charactersMaxAggregateInput'] = None,
        having: Optional['types.charactersScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.charactersCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.charactersScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.charactersScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.charactersGroupByOutput']:
        """Group characters records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar characters fields to group records by
        where
            characters filter to select records
        take
            Limit the maximum number of characters records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.charactersGroupByOutput]
            A list of dictionaries representing the characters record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group characters records by CharacterID values
        # and count how many records are in each group
        results = await characters.prisma().group_by(
            ['CharacterID'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='characters',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class characters_imagesActions:
    def __init__(self, client: 'Client', model: Type['models.characters_images']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.characters_images']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.characters_images]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await characters_images.prisma().query_raw(
            'SELECT * FROM characters_images WHERE uid = ?',
            790425851,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.characters_images']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.characters_images
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await characters_images.prisma().query_first(
            'SELECT * FROM characters_images WHERE CharacterID = ?',
            2111915288,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.characters_imagesCreateInput,
        include: Optional[types.characters_imagesInclude] = None
    ) -> 'models.characters_images':
        """Create a new characters_images record.

        Parameters
        ----------
        data
            characters_images record data
        include
            Specifies which relations should be loaded on the returned characters_images model

        Returns
        -------
        prisma.models.characters_images
            The created characters_images record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a characters_images record from just the required fields
        characters_images = await characters_images.prisma().create(
            data={
                # data to create a characters_images record
                'CharacterID': 1149758321,
                'ImageID': 1644289366,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='characters_images',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.characters_imagesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple characters_images records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of characters_images record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await characters_images.prisma().create_many(
            data=[
                {
                    # data to create a characters_images record
                    'CharacterID': 1388290519,
                    'ImageID': 1647418052,
                },
                {
                    # data to create a characters_images record
                    'CharacterID': 1675546029,
                    'ImageID': 1767274722,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='characters_images',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.characters_imagesWhereUniqueInput,
        include: Optional[types.characters_imagesInclude] = None
    ) -> Optional['models.characters_images']:
        """Delete a single characters_images record.

        Parameters
        ----------
        where
            characters_images filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned characters_images model

        Returns
        -------
        prisma.models.characters_images
            The deleted characters_images record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters_images = await characters_images.prisma().delete(
            where={
                'uid': 326272115,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='characters_images',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.characters_imagesWhereUniqueInput,
        include: Optional[types.characters_imagesInclude] = None
    ) -> Optional['models.characters_images']:
        """Find a unique characters_images record.

        Parameters
        ----------
        where
            characters_images filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned characters_images model

        Returns
        -------
        prisma.models.characters_images
            The found characters_images record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters_images = await characters_images.prisma().find_unique(
            where={
                'uid': 1343201072,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='characters_images',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.characters_imagesWhereInput] = None,
        cursor: Optional[types.characters_imagesWhereUniqueInput] = None,
        include: Optional[types.characters_imagesInclude] = None,
        order: Optional[Union[types.characters_imagesOrderByInput, List[types.characters_imagesOrderByInput]]] = None,
    ) -> List['models.characters_images']:
        """Find multiple characters_images records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of characters_images records returned
        skip
            Ignore the first N results
        where
            characters_images filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned characters_images model
        order
            Order the returned characters_images records by any field

        Returns
        -------
        List[prisma.models.characters_images]
            The list of all characters_images records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 characters_images records
        characters_images = await characters_images.prisma().find_many(take=10)

        # find the first 5 characters_images records ordered by the ImageID field
        characters_images = await characters_images.prisma().find_many(
            take=5,
            order={
                'ImageID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='characters_images',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.characters_imagesWhereInput] = None,
        cursor: Optional[types.characters_imagesWhereUniqueInput] = None,
        include: Optional[types.characters_imagesInclude] = None,
        order: Optional[Union[types.characters_imagesOrderByInput, List[types.characters_imagesOrderByInput]]] = None,
    ) -> Optional['models.characters_images']:
        """Find a single characters_images record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            characters_images filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned characters_images model
        order
            Order the returned characters_images records by any field

        Returns
        -------
        prisma.models.characters_images
            The first characters_images record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second characters_images record ordered by the uid field
        characters_images = await characters_images.prisma().find_first(
            skip=1,
            order={
                'uid': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='characters_images',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.characters_imagesUpdateInput,
        where: types.characters_imagesWhereUniqueInput,
        include: Optional[types.characters_imagesInclude] = None
    ) -> Optional['models.characters_images']:
        """Update a single characters_images record.

        Parameters
        ----------
        data
            characters_images record data specifying what to update
        where
            characters_images filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned characters_images model

        Returns
        -------
        prisma.models.characters_images
            The updated characters_images record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        characters_images = await characters_images.prisma().update(
            where={
                'uid': 675780521,
            },
            data={
                # data to update the characters_images record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='characters_images',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.characters_imagesWhereUniqueInput,
        data: types.characters_imagesUpsertInput,
        include: Optional[types.characters_imagesInclude] = None,
    ) -> 'models.characters_images':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            characters_images filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned characters_images model

        Returns
        -------
        prisma.models.characters_images
            The created or updated characters_images record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters_images = await characters_images.prisma().upsert(
            where={
                'uid': 744964398,
            },
            data={
                'create': {
                    'uid': 744964398,
                    'CharacterID': 1675546029,
                    'ImageID': 1767274722,
                },
                'update': {
                    'CharacterID': 1675546029,
                    'ImageID': 1767274722,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='characters_images',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.characters_imagesUpdateManyMutationInput,
        where: types.characters_imagesWhereInput,
    ) -> int:
        """Update multiple characters_images records

        Parameters
        ----------
        data
            characters_images data to update the selected characters_images records to
        where
            Filter to select the characters_images records to update

        Returns
        -------
        int
            The total number of characters_images records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all characters_images records
        total = await characters_images.prisma().update_many(
            data={
                'CharacterID': 1969681615
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='characters_images',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.characters_imagesWhereInput] = None,
        cursor: Optional[types.characters_imagesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of characters_images records present in the database

        Parameters
        ----------
        select
            Select the characters_images fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            characters_images filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.characters_imagesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await characters_images.prisma().count()

        # results: prisma.types.characters_imagesCountAggregateOutput
        results = await characters_images.prisma().count(
            select={
                '_all': True,
                'ImageID': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.characters_imagesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.characters_imagesWhereInput] = None,
        cursor: Optional[types.characters_imagesWhereUniqueInput] = None,
    ) -> types.characters_imagesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.characters_imagesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.characters_imagesWhereInput] = None,
        cursor: Optional[types.characters_imagesWhereUniqueInput] = None,
    ) -> Union[int, types.characters_imagesCountAggregateOutput]:
        """Count the number of characters_images records present in the database

        Parameters
        ----------
        select
            Select the characters_images fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            characters_images filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.characters_imagesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await characters_images.prisma().count()

        # results: prisma.types.characters_imagesCountAggregateOutput
        results = await characters_images.prisma().count(
            select={
                '_all': True,
                'uid': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='characters_images',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.characters_imagesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.characters_imagesWhereInput] = None
    ) -> int:
        """Delete multiple characters_images records.

        Parameters
        ----------
        where
            Optional characters_images filter to find the records to be deleted

        Returns
        -------
        int
            The total number of characters_images records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all characters_images records
        total = await characters_images.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='characters_images',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.characters_imagesScalarFieldKeys'],
        *,
        where: Optional['types.characters_imagesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.characters_imagesAvgAggregateInput'] = None,
        sum: Optional['types.characters_imagesSumAggregateInput'] = None,
        min: Optional['types.characters_imagesMinAggregateInput'] = None,
        max: Optional['types.characters_imagesMaxAggregateInput'] = None,
        having: Optional['types.characters_imagesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.characters_imagesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.characters_imagesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.characters_imagesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.characters_imagesGroupByOutput']:
        """Group characters_images records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar characters_images fields to group records by
        where
            characters_images filter to select records
        take
            Limit the maximum number of characters_images records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.characters_imagesGroupByOutput]
            A list of dictionaries representing the characters_images record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group characters_images records by CharacterID values
        # and count how many records are in each group
        results = await characters_images.prisma().group_by(
            ['CharacterID'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='characters_images',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class characters_kindsActions:
    def __init__(self, client: 'Client', model: Type['models.characters_kinds']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.characters_kinds']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.characters_kinds]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await characters_kinds.prisma().query_raw(
            'SELECT * FROM characters_kinds WHERE uid = ?',
            1116175964,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.characters_kinds']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.characters_kinds
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await characters_kinds.prisma().query_first(
            'SELECT * FROM characters_kinds WHERE CharacterID = ?',
            861472101,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.characters_kindsCreateInput,
        include: Optional[types.characters_kindsInclude] = None
    ) -> 'models.characters_kinds':
        """Create a new characters_kinds record.

        Parameters
        ----------
        data
            characters_kinds record data
        include
            Specifies which relations should be loaded on the returned characters_kinds model

        Returns
        -------
        prisma.models.characters_kinds
            The created characters_kinds record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a characters_kinds record from just the required fields
        characters_kinds = await characters_kinds.prisma().create(
            data={
                # data to create a characters_kinds record
                'CharacterID': 1303003706,
                'KindID': 1686638315,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='characters_kinds',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.characters_kindsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple characters_kinds records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of characters_kinds record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await characters_kinds.prisma().create_many(
            data=[
                {
                    # data to create a characters_kinds record
                    'CharacterID': 2000430152,
                    'KindID': 1868141281,
                },
                {
                    # data to create a characters_kinds record
                    'CharacterID': 1860847622,
                    'KindID': 1448521415,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='characters_kinds',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.characters_kindsWhereUniqueInput,
        include: Optional[types.characters_kindsInclude] = None
    ) -> Optional['models.characters_kinds']:
        """Delete a single characters_kinds record.

        Parameters
        ----------
        where
            characters_kinds filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned characters_kinds model

        Returns
        -------
        prisma.models.characters_kinds
            The deleted characters_kinds record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters_kinds = await characters_kinds.prisma().delete(
            where={
                'uid': 1628650740,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='characters_kinds',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.characters_kindsWhereUniqueInput,
        include: Optional[types.characters_kindsInclude] = None
    ) -> Optional['models.characters_kinds']:
        """Find a unique characters_kinds record.

        Parameters
        ----------
        where
            characters_kinds filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned characters_kinds model

        Returns
        -------
        prisma.models.characters_kinds
            The found characters_kinds record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters_kinds = await characters_kinds.prisma().find_unique(
            where={
                'uid': 1249606685,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='characters_kinds',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.characters_kindsWhereInput] = None,
        cursor: Optional[types.characters_kindsWhereUniqueInput] = None,
        include: Optional[types.characters_kindsInclude] = None,
        order: Optional[Union[types.characters_kindsOrderByInput, List[types.characters_kindsOrderByInput]]] = None,
    ) -> List['models.characters_kinds']:
        """Find multiple characters_kinds records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of characters_kinds records returned
        skip
            Ignore the first N results
        where
            characters_kinds filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned characters_kinds model
        order
            Order the returned characters_kinds records by any field

        Returns
        -------
        List[prisma.models.characters_kinds]
            The list of all characters_kinds records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 characters_kinds records
        characters_kinds = await characters_kinds.prisma().find_many(take=10)

        # find the first 5 characters_kinds records ordered by the KindID field
        characters_kinds = await characters_kinds.prisma().find_many(
            take=5,
            order={
                'KindID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='characters_kinds',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.characters_kindsWhereInput] = None,
        cursor: Optional[types.characters_kindsWhereUniqueInput] = None,
        include: Optional[types.characters_kindsInclude] = None,
        order: Optional[Union[types.characters_kindsOrderByInput, List[types.characters_kindsOrderByInput]]] = None,
    ) -> Optional['models.characters_kinds']:
        """Find a single characters_kinds record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            characters_kinds filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned characters_kinds model
        order
            Order the returned characters_kinds records by any field

        Returns
        -------
        prisma.models.characters_kinds
            The first characters_kinds record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second characters_kinds record ordered by the Comment field
        characters_kinds = await characters_kinds.prisma().find_first(
            skip=1,
            order={
                'Comment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='characters_kinds',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.characters_kindsUpdateInput,
        where: types.characters_kindsWhereUniqueInput,
        include: Optional[types.characters_kindsInclude] = None
    ) -> Optional['models.characters_kinds']:
        """Update a single characters_kinds record.

        Parameters
        ----------
        data
            characters_kinds record data specifying what to update
        where
            characters_kinds filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned characters_kinds model

        Returns
        -------
        prisma.models.characters_kinds
            The updated characters_kinds record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        characters_kinds = await characters_kinds.prisma().update(
            where={
                'uid': 835903122,
            },
            data={
                # data to update the characters_kinds record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='characters_kinds',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.characters_kindsWhereUniqueInput,
        data: types.characters_kindsUpsertInput,
        include: Optional[types.characters_kindsInclude] = None,
    ) -> 'models.characters_kinds':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            characters_kinds filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned characters_kinds model

        Returns
        -------
        prisma.models.characters_kinds
            The created or updated characters_kinds record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        characters_kinds = await characters_kinds.prisma().upsert(
            where={
                'uid': 763719779,
            },
            data={
                'create': {
                    'uid': 763719779,
                    'CharacterID': 1860847622,
                    'KindID': 1448521415,
                },
                'update': {
                    'CharacterID': 1860847622,
                    'KindID': 1448521415,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='characters_kinds',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.characters_kindsUpdateManyMutationInput,
        where: types.characters_kindsWhereInput,
    ) -> int:
        """Update multiple characters_kinds records

        Parameters
        ----------
        data
            characters_kinds data to update the selected characters_kinds records to
        where
            Filter to select the characters_kinds records to update

        Returns
        -------
        int
            The total number of characters_kinds records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all characters_kinds records
        total = await characters_kinds.prisma().update_many(
            data={
                'uid': 429995104
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='characters_kinds',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.characters_kindsWhereInput] = None,
        cursor: Optional[types.characters_kindsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of characters_kinds records present in the database

        Parameters
        ----------
        select
            Select the characters_kinds fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            characters_kinds filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.characters_kindsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await characters_kinds.prisma().count()

        # results: prisma.types.characters_kindsCountAggregateOutput
        results = await characters_kinds.prisma().count(
            select={
                '_all': True,
                'CharacterID': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.characters_kindsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.characters_kindsWhereInput] = None,
        cursor: Optional[types.characters_kindsWhereUniqueInput] = None,
    ) -> types.characters_kindsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.characters_kindsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.characters_kindsWhereInput] = None,
        cursor: Optional[types.characters_kindsWhereUniqueInput] = None,
    ) -> Union[int, types.characters_kindsCountAggregateOutput]:
        """Count the number of characters_kinds records present in the database

        Parameters
        ----------
        select
            Select the characters_kinds fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            characters_kinds filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.characters_kindsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await characters_kinds.prisma().count()

        # results: prisma.types.characters_kindsCountAggregateOutput
        results = await characters_kinds.prisma().count(
            select={
                '_all': True,
                'KindID': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='characters_kinds',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.characters_kindsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.characters_kindsWhereInput] = None
    ) -> int:
        """Delete multiple characters_kinds records.

        Parameters
        ----------
        where
            Optional characters_kinds filter to find the records to be deleted

        Returns
        -------
        int
            The total number of characters_kinds records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all characters_kinds records
        total = await characters_kinds.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='characters_kinds',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.characters_kindsScalarFieldKeys'],
        *,
        where: Optional['types.characters_kindsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.characters_kindsAvgAggregateInput'] = None,
        sum: Optional['types.characters_kindsSumAggregateInput'] = None,
        min: Optional['types.characters_kindsMinAggregateInput'] = None,
        max: Optional['types.characters_kindsMaxAggregateInput'] = None,
        having: Optional['types.characters_kindsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.characters_kindsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.characters_kindsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.characters_kindsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.characters_kindsGroupByOutput']:
        """Group characters_kinds records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar characters_kinds fields to group records by
        where
            characters_kinds filter to select records
        take
            Limit the maximum number of characters_kinds records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.characters_kindsGroupByOutput]
            A list of dictionaries representing the characters_kinds record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group characters_kinds records by Comment values
        # and count how many records are in each group
        results = await characters_kinds.prisma().group_by(
            ['Comment'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='characters_kinds',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class comics_issuesActions:
    def __init__(self, client: 'Client', model: Type['models.comics_issues']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.comics_issues']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.comics_issues]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await comics_issues.prisma().query_raw(
            'SELECT * FROM comics_issues WHERE ComicsIssueID = ?',
            1775811865,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.comics_issues']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.comics_issues
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await comics_issues.prisma().query_first(
            'SELECT * FROM comics_issues WHERE IssueNo = ?',
            893145566,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.comics_issuesCreateInput,
        include: Optional[types.comics_issuesInclude] = None
    ) -> 'models.comics_issues':
        """Create a new comics_issues record.

        Parameters
        ----------
        data
            comics_issues record data
        include
            Specifies which relations should be loaded on the returned comics_issues model

        Returns
        -------
        prisma.models.comics_issues
            The created comics_issues record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a comics_issues record from just the required fields
        comics_issues = await comics_issues.prisma().create(
            data={
                # data to create a comics_issues record
                'ComicsStoryID': 995405759,
                'PublishDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='comics_issues',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.comics_issuesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple comics_issues records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of comics_issues record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await comics_issues.prisma().create_many(
            data=[
                {
                    # data to create a comics_issues record
                    'ComicsStoryID': 2102736524,
                    'PublishDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a comics_issues record
                    'ComicsStoryID': 271520213,
                    'PublishDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='comics_issues',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.comics_issuesWhereUniqueInput,
        include: Optional[types.comics_issuesInclude] = None
    ) -> Optional['models.comics_issues']:
        """Delete a single comics_issues record.

        Parameters
        ----------
        where
            comics_issues filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned comics_issues model

        Returns
        -------
        prisma.models.comics_issues
            The deleted comics_issues record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_issues = await comics_issues.prisma().delete(
            where={
                'ComicsIssueID': 456633834,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='comics_issues',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.comics_issuesWhereUniqueInput,
        include: Optional[types.comics_issuesInclude] = None
    ) -> Optional['models.comics_issues']:
        """Find a unique comics_issues record.

        Parameters
        ----------
        where
            comics_issues filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned comics_issues model

        Returns
        -------
        prisma.models.comics_issues
            The found comics_issues record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_issues = await comics_issues.prisma().find_unique(
            where={
                'ComicsIssueID': 2058258651,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='comics_issues',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_issuesWhereInput] = None,
        cursor: Optional[types.comics_issuesWhereUniqueInput] = None,
        include: Optional[types.comics_issuesInclude] = None,
        order: Optional[Union[types.comics_issuesOrderByInput, List[types.comics_issuesOrderByInput]]] = None,
    ) -> List['models.comics_issues']:
        """Find multiple comics_issues records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of comics_issues records returned
        skip
            Ignore the first N results
        where
            comics_issues filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned comics_issues model
        order
            Order the returned comics_issues records by any field

        Returns
        -------
        List[prisma.models.comics_issues]
            The list of all comics_issues records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 comics_issues records
        comics_issues = await comics_issues.prisma().find_many(take=10)

        # find the first 5 comics_issues records ordered by the ComicsStoryID field
        comics_issues = await comics_issues.prisma().find_many(
            take=5,
            order={
                'ComicsStoryID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='comics_issues',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.comics_issuesWhereInput] = None,
        cursor: Optional[types.comics_issuesWhereUniqueInput] = None,
        include: Optional[types.comics_issuesInclude] = None,
        order: Optional[Union[types.comics_issuesOrderByInput, List[types.comics_issuesOrderByInput]]] = None,
    ) -> Optional['models.comics_issues']:
        """Find a single comics_issues record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            comics_issues filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned comics_issues model
        order
            Order the returned comics_issues records by any field

        Returns
        -------
        prisma.models.comics_issues
            The first comics_issues record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second comics_issues record ordered by the PublishDate field
        comics_issues = await comics_issues.prisma().find_first(
            skip=1,
            order={
                'PublishDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='comics_issues',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.comics_issuesUpdateInput,
        where: types.comics_issuesWhereUniqueInput,
        include: Optional[types.comics_issuesInclude] = None
    ) -> Optional['models.comics_issues']:
        """Update a single comics_issues record.

        Parameters
        ----------
        data
            comics_issues record data specifying what to update
        where
            comics_issues filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned comics_issues model

        Returns
        -------
        prisma.models.comics_issues
            The updated comics_issues record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        comics_issues = await comics_issues.prisma().update(
            where={
                'ComicsIssueID': 1583689592,
            },
            data={
                # data to update the comics_issues record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='comics_issues',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.comics_issuesWhereUniqueInput,
        data: types.comics_issuesUpsertInput,
        include: Optional[types.comics_issuesInclude] = None,
    ) -> 'models.comics_issues':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            comics_issues filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned comics_issues model

        Returns
        -------
        prisma.models.comics_issues
            The created or updated comics_issues record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_issues = await comics_issues.prisma().upsert(
            where={
                'ComicsIssueID': 878442065,
            },
            data={
                'create': {
                    'ComicsIssueID': 878442065,
                    'ComicsStoryID': 271520213,
                    'PublishDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'ComicsStoryID': 271520213,
                    'PublishDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='comics_issues',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.comics_issuesUpdateManyMutationInput,
        where: types.comics_issuesWhereInput,
    ) -> int:
        """Update multiple comics_issues records

        Parameters
        ----------
        data
            comics_issues data to update the selected comics_issues records to
        where
            Filter to select the comics_issues records to update

        Returns
        -------
        int
            The total number of comics_issues records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all comics_issues records
        total = await comics_issues.prisma().update_many(
            data={
                'Annotation': 'bghfciaafe'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='comics_issues',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_issuesWhereInput] = None,
        cursor: Optional[types.comics_issuesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of comics_issues records present in the database

        Parameters
        ----------
        select
            Select the comics_issues fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            comics_issues filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.comics_issuesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await comics_issues.prisma().count()

        # results: prisma.types.comics_issuesCountAggregateOutput
        results = await comics_issues.prisma().count(
            select={
                '_all': True,
                'ComicsIssueID': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.comics_issuesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_issuesWhereInput] = None,
        cursor: Optional[types.comics_issuesWhereUniqueInput] = None,
    ) -> types.comics_issuesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.comics_issuesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_issuesWhereInput] = None,
        cursor: Optional[types.comics_issuesWhereUniqueInput] = None,
    ) -> Union[int, types.comics_issuesCountAggregateOutput]:
        """Count the number of comics_issues records present in the database

        Parameters
        ----------
        select
            Select the comics_issues fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            comics_issues filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.comics_issuesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await comics_issues.prisma().count()

        # results: prisma.types.comics_issuesCountAggregateOutput
        results = await comics_issues.prisma().count(
            select={
                '_all': True,
                'IssueNo': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='comics_issues',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.comics_issuesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.comics_issuesWhereInput] = None
    ) -> int:
        """Delete multiple comics_issues records.

        Parameters
        ----------
        where
            Optional comics_issues filter to find the records to be deleted

        Returns
        -------
        int
            The total number of comics_issues records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all comics_issues records
        total = await comics_issues.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='comics_issues',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.comics_issuesScalarFieldKeys'],
        *,
        where: Optional['types.comics_issuesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.comics_issuesAvgAggregateInput'] = None,
        sum: Optional['types.comics_issuesSumAggregateInput'] = None,
        min: Optional['types.comics_issuesMinAggregateInput'] = None,
        max: Optional['types.comics_issuesMaxAggregateInput'] = None,
        having: Optional['types.comics_issuesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.comics_issuesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.comics_issuesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.comics_issuesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.comics_issuesGroupByOutput']:
        """Group comics_issues records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar comics_issues fields to group records by
        where
            comics_issues filter to select records
        take
            Limit the maximum number of comics_issues records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.comics_issuesGroupByOutput]
            A list of dictionaries representing the comics_issues record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group comics_issues records by ComicsStoryID values
        # and count how many records are in each group
        results = await comics_issues.prisma().group_by(
            ['ComicsStoryID'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='comics_issues',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class comics_seriesActions:
    def __init__(self, client: 'Client', model: Type['models.comics_series']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.comics_series']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.comics_series]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await comics_series.prisma().query_raw(
            'SELECT * FROM comics_series WHERE ComicsSeriesID = ?',
            1627576247,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.comics_series']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.comics_series
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await comics_series.prisma().query_first(
            'SELECT * FROM comics_series WHERE Name = ?',
            'cafeiaccbc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.comics_seriesCreateInput,
        include: Optional[types.comics_seriesInclude] = None
    ) -> 'models.comics_series':
        """Create a new comics_series record.

        Parameters
        ----------
        data
            comics_series record data
        include
            Specifies which relations should be loaded on the returned comics_series model

        Returns
        -------
        prisma.models.comics_series
            The created comics_series record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a comics_series record from just the required fields
        comics_series = await comics_series.prisma().create(
            data={
                # data to create a comics_series record
                'Name': 'gaddfhfh',
                'Url': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='comics_series',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.comics_seriesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple comics_series records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of comics_series record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await comics_series.prisma().create_many(
            data=[
                {
                    # data to create a comics_series record
                    'Name': 'bgcffadich',
                    'Url': 'fcbichhci',
                },
                {
                    # data to create a comics_series record
                    'Name': 'bcggadccgf',
                    'Url': 'jdcfdcgc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='comics_series',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.comics_seriesWhereUniqueInput,
        include: Optional[types.comics_seriesInclude] = None
    ) -> Optional['models.comics_series']:
        """Delete a single comics_series record.

        Parameters
        ----------
        where
            comics_series filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned comics_series model

        Returns
        -------
        prisma.models.comics_series
            The deleted comics_series record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_series = await comics_series.prisma().delete(
            where={
                'ComicsSeriesID': 2053047983,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='comics_series',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.comics_seriesWhereUniqueInput,
        include: Optional[types.comics_seriesInclude] = None
    ) -> Optional['models.comics_series']:
        """Find a unique comics_series record.

        Parameters
        ----------
        where
            comics_series filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned comics_series model

        Returns
        -------
        prisma.models.comics_series
            The found comics_series record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_series = await comics_series.prisma().find_unique(
            where={
                'ComicsSeriesID': 685333180,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='comics_series',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_seriesWhereInput] = None,
        cursor: Optional[types.comics_seriesWhereUniqueInput] = None,
        include: Optional[types.comics_seriesInclude] = None,
        order: Optional[Union[types.comics_seriesOrderByInput, List[types.comics_seriesOrderByInput]]] = None,
    ) -> List['models.comics_series']:
        """Find multiple comics_series records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of comics_series records returned
        skip
            Ignore the first N results
        where
            comics_series filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned comics_series model
        order
            Order the returned comics_series records by any field

        Returns
        -------
        List[prisma.models.comics_series]
            The list of all comics_series records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 comics_series records
        comics_series = await comics_series.prisma().find_many(take=10)

        # find the first 5 comics_series records ordered by the Url field
        comics_series = await comics_series.prisma().find_many(
            take=5,
            order={
                'Url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='comics_series',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.comics_seriesWhereInput] = None,
        cursor: Optional[types.comics_seriesWhereUniqueInput] = None,
        include: Optional[types.comics_seriesInclude] = None,
        order: Optional[Union[types.comics_seriesOrderByInput, List[types.comics_seriesOrderByInput]]] = None,
    ) -> Optional['models.comics_series']:
        """Find a single comics_series record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            comics_series filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned comics_series model
        order
            Order the returned comics_series records by any field

        Returns
        -------
        prisma.models.comics_series
            The first comics_series record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second comics_series record ordered by the ComicsSeriesID field
        comics_series = await comics_series.prisma().find_first(
            skip=1,
            order={
                'ComicsSeriesID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='comics_series',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.comics_seriesUpdateInput,
        where: types.comics_seriesWhereUniqueInput,
        include: Optional[types.comics_seriesInclude] = None
    ) -> Optional['models.comics_series']:
        """Update a single comics_series record.

        Parameters
        ----------
        data
            comics_series record data specifying what to update
        where
            comics_series filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned comics_series model

        Returns
        -------
        prisma.models.comics_series
            The updated comics_series record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        comics_series = await comics_series.prisma().update(
            where={
                'ComicsSeriesID': 127474245,
            },
            data={
                # data to update the comics_series record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='comics_series',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.comics_seriesWhereUniqueInput,
        data: types.comics_seriesUpsertInput,
        include: Optional[types.comics_seriesInclude] = None,
    ) -> 'models.comics_series':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            comics_series filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned comics_series model

        Returns
        -------
        prisma.models.comics_series
            The created or updated comics_series record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_series = await comics_series.prisma().upsert(
            where={
                'ComicsSeriesID': 948921754,
            },
            data={
                'create': {
                    'ComicsSeriesID': 948921754,
                    'Name': 'bcggadccgf',
                    'Url': 'jdcfdcgc',
                },
                'update': {
                    'Name': 'bcggadccgf',
                    'Url': 'jdcfdcgc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='comics_series',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.comics_seriesUpdateManyMutationInput,
        where: types.comics_seriesWhereInput,
    ) -> int:
        """Update multiple comics_series records

        Parameters
        ----------
        data
            comics_series data to update the selected comics_series records to
        where
            Filter to select the comics_series records to update

        Returns
        -------
        int
            The total number of comics_series records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all comics_series records
        total = await comics_series.prisma().update_many(
            data={
                'Name': 'bjgejjabff'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='comics_series',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_seriesWhereInput] = None,
        cursor: Optional[types.comics_seriesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of comics_series records present in the database

        Parameters
        ----------
        select
            Select the comics_series fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            comics_series filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.comics_seriesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await comics_series.prisma().count()

        # results: prisma.types.comics_seriesCountAggregateOutput
        results = await comics_series.prisma().count(
            select={
                '_all': True,
                'Url': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.comics_seriesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_seriesWhereInput] = None,
        cursor: Optional[types.comics_seriesWhereUniqueInput] = None,
    ) -> types.comics_seriesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.comics_seriesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_seriesWhereInput] = None,
        cursor: Optional[types.comics_seriesWhereUniqueInput] = None,
    ) -> Union[int, types.comics_seriesCountAggregateOutput]:
        """Count the number of comics_series records present in the database

        Parameters
        ----------
        select
            Select the comics_series fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            comics_series filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.comics_seriesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await comics_series.prisma().count()

        # results: prisma.types.comics_seriesCountAggregateOutput
        results = await comics_series.prisma().count(
            select={
                '_all': True,
                'ComicsSeriesID': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='comics_series',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.comics_seriesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.comics_seriesWhereInput] = None
    ) -> int:
        """Delete multiple comics_series records.

        Parameters
        ----------
        where
            Optional comics_series filter to find the records to be deleted

        Returns
        -------
        int
            The total number of comics_series records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all comics_series records
        total = await comics_series.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='comics_series',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.comics_seriesScalarFieldKeys'],
        *,
        where: Optional['types.comics_seriesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.comics_seriesAvgAggregateInput'] = None,
        sum: Optional['types.comics_seriesSumAggregateInput'] = None,
        min: Optional['types.comics_seriesMinAggregateInput'] = None,
        max: Optional['types.comics_seriesMaxAggregateInput'] = None,
        having: Optional['types.comics_seriesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.comics_seriesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.comics_seriesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.comics_seriesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.comics_seriesGroupByOutput']:
        """Group comics_series records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar comics_series fields to group records by
        where
            comics_series filter to select records
        take
            Limit the maximum number of comics_series records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.comics_seriesGroupByOutput]
            A list of dictionaries representing the comics_series record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group comics_series records by Name values
        # and count how many records are in each group
        results = await comics_series.prisma().group_by(
            ['Name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='comics_series',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class comics_storiesActions:
    def __init__(self, client: 'Client', model: Type['models.comics_stories']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.comics_stories']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.comics_stories]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await comics_stories.prisma().query_raw(
            'SELECT * FROM comics_stories WHERE ComicsStoryID = ?',
            1228891816,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.comics_stories']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.comics_stories
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await comics_stories.prisma().query_first(
            'SELECT * FROM comics_stories WHERE Name = ?',
            'cffcachfd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.comics_storiesCreateInput,
        include: Optional[types.comics_storiesInclude] = None
    ) -> 'models.comics_stories':
        """Create a new comics_stories record.

        Parameters
        ----------
        data
            comics_stories record data
        include
            Specifies which relations should be loaded on the returned comics_stories model

        Returns
        -------
        prisma.models.comics_stories
            The created comics_stories record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a comics_stories record from just the required fields
        comics_stories = await comics_stories.prisma().create(
            data={
                # data to create a comics_stories record
                'Name': 'bccdfhdigc',
                'ComicsSeriesID': 541269159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='comics_stories',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.comics_storiesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple comics_stories records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of comics_stories record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await comics_stories.prisma().create_many(
            data=[
                {
                    # data to create a comics_stories record
                    'Name': 'bageiegghg',
                    'ComicsSeriesID': 508382461,
                },
                {
                    # data to create a comics_stories record
                    'Name': 'bacecgfhbe',
                    'ComicsSeriesID': 872078403,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='comics_stories',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.comics_storiesWhereUniqueInput,
        include: Optional[types.comics_storiesInclude] = None
    ) -> Optional['models.comics_stories']:
        """Delete a single comics_stories record.

        Parameters
        ----------
        where
            comics_stories filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned comics_stories model

        Returns
        -------
        prisma.models.comics_stories
            The deleted comics_stories record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_stories = await comics_stories.prisma().delete(
            where={
                'ComicsStoryID': 1874748096,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='comics_stories',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.comics_storiesWhereUniqueInput,
        include: Optional[types.comics_storiesInclude] = None
    ) -> Optional['models.comics_stories']:
        """Find a unique comics_stories record.

        Parameters
        ----------
        where
            comics_stories filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned comics_stories model

        Returns
        -------
        prisma.models.comics_stories
            The found comics_stories record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_stories = await comics_stories.prisma().find_unique(
            where={
                'ComicsStoryID': 916896761,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='comics_stories',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_storiesWhereInput] = None,
        cursor: Optional[types.comics_storiesWhereUniqueInput] = None,
        include: Optional[types.comics_storiesInclude] = None,
        order: Optional[Union[types.comics_storiesOrderByInput, List[types.comics_storiesOrderByInput]]] = None,
    ) -> List['models.comics_stories']:
        """Find multiple comics_stories records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of comics_stories records returned
        skip
            Ignore the first N results
        where
            comics_stories filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned comics_stories model
        order
            Order the returned comics_stories records by any field

        Returns
        -------
        List[prisma.models.comics_stories]
            The list of all comics_stories records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 comics_stories records
        comics_stories = await comics_stories.prisma().find_many(take=10)

        # find the first 5 comics_stories records ordered by the ComicsSeriesID field
        comics_stories = await comics_stories.prisma().find_many(
            take=5,
            order={
                'ComicsSeriesID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='comics_stories',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.comics_storiesWhereInput] = None,
        cursor: Optional[types.comics_storiesWhereUniqueInput] = None,
        include: Optional[types.comics_storiesInclude] = None,
        order: Optional[Union[types.comics_storiesOrderByInput, List[types.comics_storiesOrderByInput]]] = None,
    ) -> Optional['models.comics_stories']:
        """Find a single comics_stories record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            comics_stories filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned comics_stories model
        order
            Order the returned comics_stories records by any field

        Returns
        -------
        prisma.models.comics_stories
            The first comics_stories record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second comics_stories record ordered by the ImageID field
        comics_stories = await comics_stories.prisma().find_first(
            skip=1,
            order={
                'ImageID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='comics_stories',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.comics_storiesUpdateInput,
        where: types.comics_storiesWhereUniqueInput,
        include: Optional[types.comics_storiesInclude] = None
    ) -> Optional['models.comics_stories']:
        """Update a single comics_stories record.

        Parameters
        ----------
        data
            comics_stories record data specifying what to update
        where
            comics_stories filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned comics_stories model

        Returns
        -------
        prisma.models.comics_stories
            The updated comics_stories record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        comics_stories = await comics_stories.prisma().update(
            where={
                'ComicsStoryID': 769267518,
            },
            data={
                # data to update the comics_stories record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='comics_stories',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.comics_storiesWhereUniqueInput,
        data: types.comics_storiesUpsertInput,
        include: Optional[types.comics_storiesInclude] = None,
    ) -> 'models.comics_stories':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            comics_stories filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned comics_stories model

        Returns
        -------
        prisma.models.comics_stories
            The created or updated comics_stories record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comics_stories = await comics_stories.prisma().upsert(
            where={
                'ComicsStoryID': 820312479,
            },
            data={
                'create': {
                    'ComicsStoryID': 820312479,
                    'Name': 'bacecgfhbe',
                    'ComicsSeriesID': 872078403,
                },
                'update': {
                    'Name': 'bacecgfhbe',
                    'ComicsSeriesID': 872078403,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='comics_stories',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.comics_storiesUpdateManyMutationInput,
        where: types.comics_storiesWhereInput,
    ) -> int:
        """Update multiple comics_stories records

        Parameters
        ----------
        data
            comics_stories data to update the selected comics_stories records to
        where
            Filter to select the comics_stories records to update

        Returns
        -------
        int
            The total number of comics_stories records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all comics_stories records
        total = await comics_stories.prisma().update_many(
            data={
                'Url': 'jchciaee'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='comics_stories',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_storiesWhereInput] = None,
        cursor: Optional[types.comics_storiesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of comics_stories records present in the database

        Parameters
        ----------
        select
            Select the comics_stories fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            comics_stories filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.comics_storiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await comics_stories.prisma().count()

        # results: prisma.types.comics_storiesCountAggregateOutput
        results = await comics_stories.prisma().count(
            select={
                '_all': True,
                'Writer': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.comics_storiesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_storiesWhereInput] = None,
        cursor: Optional[types.comics_storiesWhereUniqueInput] = None,
    ) -> types.comics_storiesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.comics_storiesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.comics_storiesWhereInput] = None,
        cursor: Optional[types.comics_storiesWhereUniqueInput] = None,
    ) -> Union[int, types.comics_storiesCountAggregateOutput]:
        """Count the number of comics_stories records present in the database

        Parameters
        ----------
        select
            Select the comics_stories fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            comics_stories filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.comics_storiesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await comics_stories.prisma().count()

        # results: prisma.types.comics_storiesCountAggregateOutput
        results = await comics_stories.prisma().count(
            select={
                '_all': True,
                'Artist': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='comics_stories',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.comics_storiesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.comics_storiesWhereInput] = None
    ) -> int:
        """Delete multiple comics_stories records.

        Parameters
        ----------
        where
            Optional comics_stories filter to find the records to be deleted

        Returns
        -------
        int
            The total number of comics_stories records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all comics_stories records
        total = await comics_stories.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='comics_stories',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.comics_storiesScalarFieldKeys'],
        *,
        where: Optional['types.comics_storiesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.comics_storiesAvgAggregateInput'] = None,
        sum: Optional['types.comics_storiesSumAggregateInput'] = None,
        min: Optional['types.comics_storiesMinAggregateInput'] = None,
        max: Optional['types.comics_storiesMaxAggregateInput'] = None,
        having: Optional['types.comics_storiesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.comics_storiesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.comics_storiesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.comics_storiesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.comics_storiesGroupByOutput']:
        """Group comics_stories records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar comics_stories fields to group records by
        where
            comics_stories filter to select records
        take
            Limit the maximum number of comics_stories records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.comics_storiesGroupByOutput]
            A list of dictionaries representing the comics_stories record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group comics_stories records by Colorist values
        # and count how many records are in each group
        results = await comics_stories.prisma().group_by(
            ['Colorist'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='comics_stories',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class episodesActions:
    def __init__(self, client: 'Client', model: Type['models.episodes']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.episodes']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.episodes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await episodes.prisma().query_raw(
            'SELECT * FROM episodes WHERE EpisodeID = ?',
            344858293,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.episodes']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.episodes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await episodes.prisma().query_first(
            'SELECT * FROM episodes WHERE Name = ?',
            'bbcbhebbda',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.episodesCreateInput,
        include: Optional[types.episodesInclude] = None
    ) -> 'models.episodes':
        """Create a new episodes record.

        Parameters
        ----------
        data
            episodes record data
        include
            Specifies which relations should be loaded on the returned episodes model

        Returns
        -------
        prisma.models.episodes
            The created episodes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a episodes record from just the required fields
        episodes = await episodes.prisma().create(
            data={
                # data to create a episodes record
                'Name': 'bejfijgcfb',
                'ImageID': 208521688,
                'Airdate': datetime.datetime.utcnow(),
                'Url': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='episodes',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.episodesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple episodes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of episodes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await episodes.prisma().create_many(
            data=[
                {
                    # data to create a episodes record
                    'Name': 'bggajdcbbi',
                    'ImageID': 525761943,
                    'Airdate': datetime.datetime.utcnow(),
                    'Url': 'hdgcajhjg',
                },
                {
                    # data to create a episodes record
                    'Name': 'ejdjahicb',
                    'ImageID': 639686562,
                    'Airdate': datetime.datetime.utcnow(),
                    'Url': 'gfeaahdeh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='episodes',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.episodesWhereUniqueInput,
        include: Optional[types.episodesInclude] = None
    ) -> Optional['models.episodes']:
        """Delete a single episodes record.

        Parameters
        ----------
        where
            episodes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned episodes model

        Returns
        -------
        prisma.models.episodes
            The deleted episodes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        episodes = await episodes.prisma().delete(
            where={
                'EpisodeID': 1905261552,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='episodes',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.episodesWhereUniqueInput,
        include: Optional[types.episodesInclude] = None
    ) -> Optional['models.episodes']:
        """Find a unique episodes record.

        Parameters
        ----------
        where
            episodes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned episodes model

        Returns
        -------
        prisma.models.episodes
            The found episodes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        episodes = await episodes.prisma().find_unique(
            where={
                'EpisodeID': 78746985,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='episodes',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.episodesWhereInput] = None,
        cursor: Optional[types.episodesWhereUniqueInput] = None,
        include: Optional[types.episodesInclude] = None,
        order: Optional[Union[types.episodesOrderByInput, List[types.episodesOrderByInput]]] = None,
    ) -> List['models.episodes']:
        """Find multiple episodes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of episodes records returned
        skip
            Ignore the first N results
        where
            episodes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned episodes model
        order
            Order the returned episodes records by any field

        Returns
        -------
        List[prisma.models.episodes]
            The list of all episodes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 episodes records
        episodes = await episodes.prisma().find_many(take=10)

        # find the first 5 episodes records ordered by the ImageID field
        episodes = await episodes.prisma().find_many(
            take=5,
            order={
                'ImageID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='episodes',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.episodesWhereInput] = None,
        cursor: Optional[types.episodesWhereUniqueInput] = None,
        include: Optional[types.episodesInclude] = None,
        order: Optional[Union[types.episodesOrderByInput, List[types.episodesOrderByInput]]] = None,
    ) -> Optional['models.episodes']:
        """Find a single episodes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            episodes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned episodes model
        order
            Order the returned episodes records by any field

        Returns
        -------
        prisma.models.episodes
            The first episodes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second episodes record ordered by the Season field
        episodes = await episodes.prisma().find_first(
            skip=1,
            order={
                'Season': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='episodes',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.episodesUpdateInput,
        where: types.episodesWhereUniqueInput,
        include: Optional[types.episodesInclude] = None
    ) -> Optional['models.episodes']:
        """Update a single episodes record.

        Parameters
        ----------
        data
            episodes record data specifying what to update
        where
            episodes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned episodes model

        Returns
        -------
        prisma.models.episodes
            The updated episodes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        episodes = await episodes.prisma().update(
            where={
                'EpisodeID': 1398328302,
            },
            data={
                # data to update the episodes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='episodes',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.episodesWhereUniqueInput,
        data: types.episodesUpsertInput,
        include: Optional[types.episodesInclude] = None,
    ) -> 'models.episodes':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            episodes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned episodes model

        Returns
        -------
        prisma.models.episodes
            The created or updated episodes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        episodes = await episodes.prisma().upsert(
            where={
                'EpisodeID': 856000655,
            },
            data={
                'create': {
                    'EpisodeID': 856000655,
                    'Name': 'ejdjahicb',
                    'ImageID': 639686562,
                    'Airdate': datetime.datetime.utcnow(),
                    'Url': 'gfeaahdeh',
                },
                'update': {
                    'Name': 'ejdjahicb',
                    'ImageID': 639686562,
                    'Airdate': datetime.datetime.utcnow(),
                    'Url': 'gfeaahdeh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='episodes',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.episodesUpdateManyMutationInput,
        where: types.episodesWhereInput,
    ) -> int:
        """Update multiple episodes records

        Parameters
        ----------
        data
            episodes data to update the selected episodes records to
        where
            Filter to select the episodes records to update

        Returns
        -------
        int
            The total number of episodes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all episodes records
        total = await episodes.prisma().update_many(
            data={
                'Episode': 1452336924
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='episodes',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.episodesWhereInput] = None,
        cursor: Optional[types.episodesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of episodes records present in the database

        Parameters
        ----------
        select
            Select the episodes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            episodes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.episodesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await episodes.prisma().count()

        # results: prisma.types.episodesCountAggregateOutput
        results = await episodes.prisma().count(
            select={
                '_all': True,
                'OverallEpisode': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.episodesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.episodesWhereInput] = None,
        cursor: Optional[types.episodesWhereUniqueInput] = None,
    ) -> types.episodesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.episodesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.episodesWhereInput] = None,
        cursor: Optional[types.episodesWhereUniqueInput] = None,
    ) -> Union[int, types.episodesCountAggregateOutput]:
        """Count the number of episodes records present in the database

        Parameters
        ----------
        select
            Select the episodes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            episodes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.episodesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await episodes.prisma().count()

        # results: prisma.types.episodesCountAggregateOutput
        results = await episodes.prisma().count(
            select={
                '_all': True,
                'Airdate': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='episodes',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.episodesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.episodesWhereInput] = None
    ) -> int:
        """Delete multiple episodes records.

        Parameters
        ----------
        where
            Optional episodes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of episodes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all episodes records
        total = await episodes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='episodes',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.episodesScalarFieldKeys'],
        *,
        where: Optional['types.episodesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.episodesAvgAggregateInput'] = None,
        sum: Optional['types.episodesSumAggregateInput'] = None,
        min: Optional['types.episodesMinAggregateInput'] = None,
        max: Optional['types.episodesMaxAggregateInput'] = None,
        having: Optional['types.episodesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.episodesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.episodesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.episodesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.episodesGroupByOutput']:
        """Group episodes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar episodes fields to group records by
        where
            episodes filter to select records
        take
            Limit the maximum number of episodes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.episodesGroupByOutput]
            A list of dictionaries representing the episodes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group episodes records by StoryBy values
        # and count how many records are in each group
        results = await episodes.prisma().group_by(
            ['StoryBy'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='episodes',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class imagesActions:
    def __init__(self, client: 'Client', model: Type['models.images']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.images']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.images]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await images.prisma().query_raw(
            'SELECT * FROM images WHERE ImageID = ?',
            1573199653,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.images']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.images
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await images.prisma().query_first(
            'SELECT * FROM images WHERE Name = ?',
            'cabdjadaji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.imagesCreateInput,
        include: Optional[types.imagesInclude] = None
    ) -> 'models.images':
        """Create a new images record.

        Parameters
        ----------
        data
            images record data
        include
            Specifies which relations should be loaded on the returned images model

        Returns
        -------
        prisma.models.images
            The created images record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a images record from just the required fields
        images = await images.prisma().create(
            data={
                # data to create a images record
                'Name': 'faajgfadf',
                'Url': 'biaagcedjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='images',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.imagesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple images records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of images record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await images.prisma().create_many(
            data=[
                {
                    # data to create a images record
                    'Name': 'cahhaghecf',
                    'Url': 'bghcbbcidi',
                },
                {
                    # data to create a images record
                    'Name': 'jcgghhgdj',
                    'Url': 'beehgcebbg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='images',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.imagesWhereUniqueInput,
        include: Optional[types.imagesInclude] = None
    ) -> Optional['models.images']:
        """Delete a single images record.

        Parameters
        ----------
        where
            images filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned images model

        Returns
        -------
        prisma.models.images
            The deleted images record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        images = await images.prisma().delete(
            where={
                'ImageID': 1738083805,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='images',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.imagesWhereUniqueInput,
        include: Optional[types.imagesInclude] = None
    ) -> Optional['models.images']:
        """Find a unique images record.

        Parameters
        ----------
        where
            images filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned images model

        Returns
        -------
        prisma.models.images
            The found images record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        images = await images.prisma().find_unique(
            where={
                'ImageID': 340946258,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='images',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.imagesWhereInput] = None,
        cursor: Optional[types.imagesWhereUniqueInput] = None,
        include: Optional[types.imagesInclude] = None,
        order: Optional[Union[types.imagesOrderByInput, List[types.imagesOrderByInput]]] = None,
    ) -> List['models.images']:
        """Find multiple images records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of images records returned
        skip
            Ignore the first N results
        where
            images filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned images model
        order
            Order the returned images records by any field

        Returns
        -------
        List[prisma.models.images]
            The list of all images records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 images records
        images = await images.prisma().find_many(take=10)

        # find the first 5 images records ordered by the Url field
        images = await images.prisma().find_many(
            take=5,
            order={
                'Url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='images',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.imagesWhereInput] = None,
        cursor: Optional[types.imagesWhereUniqueInput] = None,
        include: Optional[types.imagesInclude] = None,
        order: Optional[Union[types.imagesOrderByInput, List[types.imagesOrderByInput]]] = None,
    ) -> Optional['models.images']:
        """Find a single images record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            images filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned images model
        order
            Order the returned images records by any field

        Returns
        -------
        prisma.models.images
            The first images record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second images record ordered by the Comment field
        images = await images.prisma().find_first(
            skip=1,
            order={
                'Comment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='images',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.imagesUpdateInput,
        where: types.imagesWhereUniqueInput,
        include: Optional[types.imagesInclude] = None
    ) -> Optional['models.images']:
        """Update a single images record.

        Parameters
        ----------
        data
            images record data specifying what to update
        where
            images filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned images model

        Returns
        -------
        prisma.models.images
            The updated images record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        images = await images.prisma().update(
            where={
                'ImageID': 601077795,
            },
            data={
                # data to update the images record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='images',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.imagesWhereUniqueInput,
        data: types.imagesUpsertInput,
        include: Optional[types.imagesInclude] = None,
    ) -> 'models.images':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            images filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned images model

        Returns
        -------
        prisma.models.images
            The created or updated images record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        images = await images.prisma().upsert(
            where={
                'ImageID': 290603296,
            },
            data={
                'create': {
                    'ImageID': 290603296,
                    'Name': 'jcgghhgdj',
                    'Url': 'beehgcebbg',
                },
                'update': {
                    'Name': 'jcgghhgdj',
                    'Url': 'beehgcebbg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='images',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.imagesUpdateManyMutationInput,
        where: types.imagesWhereInput,
    ) -> int:
        """Update multiple images records

        Parameters
        ----------
        data
            images data to update the selected images records to
        where
            Filter to select the images records to update

        Returns
        -------
        int
            The total number of images records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all images records
        total = await images.prisma().update_many(
            data={
                'ImageID': 1855826649
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='images',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.imagesWhereInput] = None,
        cursor: Optional[types.imagesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of images records present in the database

        Parameters
        ----------
        select
            Select the images fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            images filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.imagesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await images.prisma().count()

        # results: prisma.types.imagesCountAggregateOutput
        results = await images.prisma().count(
            select={
                '_all': True,
                'Name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.imagesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.imagesWhereInput] = None,
        cursor: Optional[types.imagesWhereUniqueInput] = None,
    ) -> types.imagesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.imagesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.imagesWhereInput] = None,
        cursor: Optional[types.imagesWhereUniqueInput] = None,
    ) -> Union[int, types.imagesCountAggregateOutput]:
        """Count the number of images records present in the database

        Parameters
        ----------
        select
            Select the images fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            images filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.imagesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await images.prisma().count()

        # results: prisma.types.imagesCountAggregateOutput
        results = await images.prisma().count(
            select={
                '_all': True,
                'Url': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='images',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.imagesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.imagesWhereInput] = None
    ) -> int:
        """Delete multiple images records.

        Parameters
        ----------
        where
            Optional images filter to find the records to be deleted

        Returns
        -------
        int
            The total number of images records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all images records
        total = await images.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='images',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.imagesScalarFieldKeys'],
        *,
        where: Optional['types.imagesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.imagesAvgAggregateInput'] = None,
        sum: Optional['types.imagesSumAggregateInput'] = None,
        min: Optional['types.imagesMinAggregateInput'] = None,
        max: Optional['types.imagesMaxAggregateInput'] = None,
        having: Optional['types.imagesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.imagesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.imagesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.imagesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.imagesGroupByOutput']:
        """Group images records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar images fields to group records by
        where
            images filter to select records
        take
            Limit the maximum number of images records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.imagesGroupByOutput]
            A list of dictionaries representing the images record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group images records by Comment values
        # and count how many records are in each group
        results = await images.prisma().group_by(
            ['Comment'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='images',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class kindsActions:
    def __init__(self, client: 'Client', model: Type['models.kinds']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.kinds']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.kinds]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await kinds.prisma().query_raw(
            'SELECT * FROM kinds WHERE KindID = ?',
            1611009182,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.kinds']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.kinds
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await kinds.prisma().query_first(
            'SELECT * FROM kinds WHERE Name = ?',
            'eegghdhjb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.kindsCreateInput,
        include: Optional[types.kindsInclude] = None
    ) -> 'models.kinds':
        """Create a new kinds record.

        Parameters
        ----------
        data
            kinds record data
        include
            Specifies which relations should be loaded on the returned kinds model

        Returns
        -------
        prisma.models.kinds
            The created kinds record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a kinds record from just the required fields
        kinds = await kinds.prisma().create(
            data={
                # data to create a kinds record
                'Name': 'daafgidjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='kinds',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.kindsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple kinds records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of kinds record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await kinds.prisma().create_many(
            data=[
                {
                    # data to create a kinds record
                    'Name': 'gdcgcgagj',
                },
                {
                    # data to create a kinds record
                    'Name': 'bhceabbgja',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='kinds',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.kindsWhereUniqueInput,
        include: Optional[types.kindsInclude] = None
    ) -> Optional['models.kinds']:
        """Delete a single kinds record.

        Parameters
        ----------
        where
            kinds filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned kinds model

        Returns
        -------
        prisma.models.kinds
            The deleted kinds record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        kinds = await kinds.prisma().delete(
            where={
                'KindID': 470157467,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='kinds',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.kindsWhereUniqueInput,
        include: Optional[types.kindsInclude] = None
    ) -> Optional['models.kinds']:
        """Find a unique kinds record.

        Parameters
        ----------
        where
            kinds filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned kinds model

        Returns
        -------
        prisma.models.kinds
            The found kinds record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        kinds = await kinds.prisma().find_unique(
            where={
                'KindID': 1209209912,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='kinds',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.kindsWhereInput] = None,
        cursor: Optional[types.kindsWhereUniqueInput] = None,
        include: Optional[types.kindsInclude] = None,
        order: Optional[Union[types.kindsOrderByInput, List[types.kindsOrderByInput]]] = None,
    ) -> List['models.kinds']:
        """Find multiple kinds records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of kinds records returned
        skip
            Ignore the first N results
        where
            kinds filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned kinds model
        order
            Order the returned kinds records by any field

        Returns
        -------
        List[prisma.models.kinds]
            The list of all kinds records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 kinds records
        kinds = await kinds.prisma().find_many(take=10)

        # find the first 5 kinds records ordered by the Url field
        kinds = await kinds.prisma().find_many(
            take=5,
            order={
                'Url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='kinds',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.kindsWhereInput] = None,
        cursor: Optional[types.kindsWhereUniqueInput] = None,
        include: Optional[types.kindsInclude] = None,
        order: Optional[Union[types.kindsOrderByInput, List[types.kindsOrderByInput]]] = None,
    ) -> Optional['models.kinds']:
        """Find a single kinds record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            kinds filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned kinds model
        order
            Order the returned kinds records by any field

        Returns
        -------
        prisma.models.kinds
            The first kinds record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second kinds record ordered by the KindID field
        kinds = await kinds.prisma().find_first(
            skip=1,
            order={
                'KindID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='kinds',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.kindsUpdateInput,
        where: types.kindsWhereUniqueInput,
        include: Optional[types.kindsInclude] = None
    ) -> Optional['models.kinds']:
        """Update a single kinds record.

        Parameters
        ----------
        data
            kinds record data specifying what to update
        where
            kinds filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned kinds model

        Returns
        -------
        prisma.models.kinds
            The updated kinds record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        kinds = await kinds.prisma().update(
            where={
                'KindID': 1536744465,
            },
            data={
                # data to update the kinds record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='kinds',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.kindsWhereUniqueInput,
        data: types.kindsUpsertInput,
        include: Optional[types.kindsInclude] = None,
    ) -> 'models.kinds':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            kinds filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned kinds model

        Returns
        -------
        prisma.models.kinds
            The created or updated kinds record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        kinds = await kinds.prisma().upsert(
            where={
                'KindID': 424218998,
            },
            data={
                'create': {
                    'KindID': 424218998,
                    'Name': 'bhceabbgja',
                },
                'update': {
                    'Name': 'bhceabbgja',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='kinds',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.kindsUpdateManyMutationInput,
        where: types.kindsWhereInput,
    ) -> int:
        """Update multiple kinds records

        Parameters
        ----------
        data
            kinds data to update the selected kinds records to
        where
            Filter to select the kinds records to update

        Returns
        -------
        int
            The total number of kinds records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all kinds records
        total = await kinds.prisma().update_many(
            data={
                'Name': 'cbcfgdcdhf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='kinds',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.kindsWhereInput] = None,
        cursor: Optional[types.kindsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of kinds records present in the database

        Parameters
        ----------
        select
            Select the kinds fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            kinds filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.kindsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await kinds.prisma().count()

        # results: prisma.types.kindsCountAggregateOutput
        results = await kinds.prisma().count(
            select={
                '_all': True,
                'Url': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.kindsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.kindsWhereInput] = None,
        cursor: Optional[types.kindsWhereUniqueInput] = None,
    ) -> types.kindsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.kindsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.kindsWhereInput] = None,
        cursor: Optional[types.kindsWhereUniqueInput] = None,
    ) -> Union[int, types.kindsCountAggregateOutput]:
        """Count the number of kinds records present in the database

        Parameters
        ----------
        select
            Select the kinds fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            kinds filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.kindsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await kinds.prisma().count()

        # results: prisma.types.kindsCountAggregateOutput
        results = await kinds.prisma().count(
            select={
                '_all': True,
                'KindID': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='kinds',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.kindsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.kindsWhereInput] = None
    ) -> int:
        """Delete multiple kinds records.

        Parameters
        ----------
        where
            Optional kinds filter to find the records to be deleted

        Returns
        -------
        int
            The total number of kinds records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all kinds records
        total = await kinds.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='kinds',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.kindsScalarFieldKeys'],
        *,
        where: Optional['types.kindsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.kindsAvgAggregateInput'] = None,
        sum: Optional['types.kindsSumAggregateInput'] = None,
        min: Optional['types.kindsMinAggregateInput'] = None,
        max: Optional['types.kindsMaxAggregateInput'] = None,
        having: Optional['types.kindsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.kindsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.kindsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.kindsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.kindsGroupByOutput']:
        """Group kinds records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar kinds fields to group records by
        where
            kinds filter to select records
        take
            Limit the maximum number of kinds records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.kindsGroupByOutput]
            A list of dictionaries representing the kinds record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group kinds records by Name values
        # and count how many records are in each group
        results = await kinds.prisma().group_by(
            ['Name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='kinds',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class songsActions:
    def __init__(self, client: 'Client', model: Type['models.songs']) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: str,
        *args: Any,
    ) -> List['models.songs']:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.songs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await songs.prisma().query_raw(
            'SELECT * FROM songs WHERE SongID = ?',
            536951780,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: str,
        *args: Any,
    ) -> Optional['models.songs']:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.songs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await songs.prisma().query_first(
            'SELECT * FROM songs WHERE Name = ?',
            'jcehcdchh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.songsCreateInput,
        include: Optional[types.songsInclude] = None
    ) -> 'models.songs':
        """Create a new songs record.

        Parameters
        ----------
        data
            songs record data
        include
            Specifies which relations should be loaded on the returned songs model

        Returns
        -------
        prisma.models.songs
            The created songs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a songs record from just the required fields
        songs = await songs.prisma().create(
            data={
                # data to create a songs record
                'Name': 'bgcbjdhjcc',
                'EpisodeID': 1848832019,
                'VideoUrl': 'bjcbfcieaa',
                'Length': 'cbaaechiej',
                'Url': 'iejbeaaeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='songs',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.songsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple songs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of songs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await songs.prisma().create_many(
            data=[
                {
                    # data to create a songs record
                    'Name': 'jcibfcbhf',
                    'EpisodeID': 273032060,
                    'VideoUrl': 'jicieifbh',
                    'Length': 'fbahdheji',
                    'Url': 'cbbheiicgh',
                },
                {
                    # data to create a songs record
                    'Name': 'beabjeejdg',
                    'EpisodeID': 1297607553,
                    'VideoUrl': 'fbjeiiffa',
                    'Length': 'jhgidcgbf',
                    'Url': 'bgjgecfejc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='songs',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.songsWhereUniqueInput,
        include: Optional[types.songsInclude] = None
    ) -> Optional['models.songs']:
        """Delete a single songs record.

        Parameters
        ----------
        where
            songs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned songs model

        Returns
        -------
        prisma.models.songs
            The deleted songs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        songs = await songs.prisma().delete(
            where={
                'SongID': 169262781,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='songs',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.songsWhereUniqueInput,
        include: Optional[types.songsInclude] = None
    ) -> Optional['models.songs']:
        """Find a unique songs record.

        Parameters
        ----------
        where
            songs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned songs model

        Returns
        -------
        prisma.models.songs
            The found songs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        songs = await songs.prisma().find_unique(
            where={
                'SongID': 1023081650,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='songs',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.songsWhereInput] = None,
        cursor: Optional[types.songsWhereUniqueInput] = None,
        include: Optional[types.songsInclude] = None,
        order: Optional[Union[types.songsOrderByInput, List[types.songsOrderByInput]]] = None,
    ) -> List['models.songs']:
        """Find multiple songs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of songs records returned
        skip
            Ignore the first N results
        where
            songs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned songs model
        order
            Order the returned songs records by any field

        Returns
        -------
        List[prisma.models.songs]
            The list of all songs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 songs records
        songs = await songs.prisma().find_many(take=10)

        # find the first 5 songs records ordered by the EpisodeID field
        songs = await songs.prisma().find_many(
            take=5,
            order={
                'EpisodeID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='songs',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.songsWhereInput] = None,
        cursor: Optional[types.songsWhereUniqueInput] = None,
        include: Optional[types.songsInclude] = None,
        order: Optional[Union[types.songsOrderByInput, List[types.songsOrderByInput]]] = None,
    ) -> Optional['models.songs']:
        """Find a single songs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            songs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned songs model
        order
            Order the returned songs records by any field

        Returns
        -------
        prisma.models.songs
            The first songs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second songs record ordered by the VideoUrl field
        songs = await songs.prisma().find_first(
            skip=1,
            order={
                'VideoUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='songs',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.songsUpdateInput,
        where: types.songsWhereUniqueInput,
        include: Optional[types.songsInclude] = None
    ) -> Optional['models.songs']:
        """Update a single songs record.

        Parameters
        ----------
        data
            songs record data specifying what to update
        where
            songs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned songs model

        Returns
        -------
        prisma.models.songs
            The updated songs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        songs = await songs.prisma().update(
            where={
                'SongID': 327681027,
            },
            data={
                # data to update the songs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='songs',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.songsWhereUniqueInput,
        data: types.songsUpsertInput,
        include: Optional[types.songsInclude] = None,
    ) -> 'models.songs':
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            songs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned songs model

        Returns
        -------
        prisma.models.songs
            The created or updated songs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        songs = await songs.prisma().upsert(
            where={
                'SongID': 527748992,
            },
            data={
                'create': {
                    'SongID': 527748992,
                    'Name': 'beabjeejdg',
                    'EpisodeID': 1297607553,
                    'VideoUrl': 'fbjeiiffa',
                    'Length': 'jhgidcgbf',
                    'Url': 'bgjgecfejc',
                },
                'update': {
                    'Name': 'beabjeejdg',
                    'EpisodeID': 1297607553,
                    'VideoUrl': 'fbjeiiffa',
                    'Length': 'jhgidcgbf',
                    'Url': 'bgjgecfejc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='songs',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.songsUpdateManyMutationInput,
        where: types.songsWhereInput,
    ) -> int:
        """Update multiple songs records

        Parameters
        ----------
        data
            songs data to update the selected songs records to
        where
            Filter to select the songs records to update

        Returns
        -------
        int
            The total number of songs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all songs records
        total = await songs.prisma().update_many(
            data={
                'Length': 'cacjdfhejh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='songs',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.songsWhereInput] = None,
        cursor: Optional[types.songsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of songs records present in the database

        Parameters
        ----------
        select
            Select the songs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            songs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.songsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await songs.prisma().count()

        # results: prisma.types.songsCountAggregateOutput
        results = await songs.prisma().count(
            select={
                '_all': True,
                'MusicBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.songsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.songsWhereInput] = None,
        cursor: Optional[types.songsWhereUniqueInput] = None,
    ) -> types.songsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.songsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.songsWhereInput] = None,
        cursor: Optional[types.songsWhereUniqueInput] = None,
    ) -> Union[int, types.songsCountAggregateOutput]:
        """Count the number of songs records present in the database

        Parameters
        ----------
        select
            Select the songs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            songs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.songsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await songs.prisma().count()

        # results: prisma.types.songsCountAggregateOutput
        results = await songs.prisma().count(
            select={
                '_all': True,
                'LyricsBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='songs',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.songsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.songsWhereInput] = None
    ) -> int:
        """Delete multiple songs records.

        Parameters
        ----------
        where
            Optional songs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of songs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all songs records
        total = await songs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='songs',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.songsScalarFieldKeys'],
        *,
        where: Optional['types.songsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.songsAvgAggregateInput'] = None,
        sum: Optional['types.songsSumAggregateInput'] = None,
        min: Optional['types.songsMinAggregateInput'] = None,
        max: Optional['types.songsMaxAggregateInput'] = None,
        having: Optional['types.songsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.songsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.songsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.songsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.songsGroupByOutput']:
        """Group songs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar songs fields to group records by
        where
            songs filter to select records
        take
            Limit the maximum number of songs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.songsGroupByOutput]
            A list of dictionaries representing the songs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group songs records by KeySignatures values
        # and count how many records are in each group
        results = await songs.prisma().group_by(
            ['KeySignatures'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model='songs',
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models
